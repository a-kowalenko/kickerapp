-- Migration: Create team status system with bounties for team gamemode
-- Schema: public
-- Similar to player_status but for permanent teams

SET search_path TO public;

-- ============================================
-- TEAM STATUS TABLE
-- Tracks each team's current status effects and bounties
-- ============================================
CREATE TABLE IF NOT EXISTS public.team_status (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    team_id BIGINT NOT NULL REFERENCES public.teams(id) ON DELETE CASCADE,
    -- Current streak (positive = wins, negative = losses)
    current_streak INT NOT NULL DEFAULT 0,
    -- Accumulated bounty from streak (in MMR)
    current_bounty INT NOT NULL DEFAULT 0,
    -- Active status effects (keys from status_definitions)
    active_statuses TEXT[] DEFAULT '{}',
    -- Last match that affected this status
    last_match_id BIGINT,
    -- Timestamps
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    -- One entry per team
    CONSTRAINT team_status_unique UNIQUE (team_id)
);

-- ============================================
-- TEAM BOUNTY HISTORY TABLE
-- Tracks bounty payouts between teams
-- ============================================
CREATE TABLE IF NOT EXISTS public.team_bounty_history (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- Team who claimed the bounty
    claimer_team_id BIGINT NOT NULL REFERENCES public.teams(id) ON DELETE CASCADE,
    -- Team whose streak was broken
    victim_team_id BIGINT NOT NULL REFERENCES public.teams(id) ON DELETE CASCADE,
    -- Match where the bounty was claimed
    match_id BIGINT NOT NULL,
    -- The streak that was broken
    streak_broken INT NOT NULL,
    -- Bounty amount paid out
    bounty_amount INT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================
-- INDEXES
-- ============================================
CREATE INDEX IF NOT EXISTS idx_team_status_team ON public.team_status(team_id);
CREATE INDEX IF NOT EXISTS idx_team_status_updated ON public.team_status(updated_at);
CREATE INDEX IF NOT EXISTS idx_team_bounty_history_claimer ON public.team_bounty_history(claimer_team_id);
CREATE INDEX IF NOT EXISTS idx_team_bounty_history_victim ON public.team_bounty_history(victim_team_id);
CREATE INDEX IF NOT EXISTS idx_team_bounty_history_created ON public.team_bounty_history(created_at);

-- ============================================
-- RLS POLICIES
-- ============================================
ALTER TABLE public.team_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.team_bounty_history ENABLE ROW LEVEL SECURITY;

-- Team status: Users can view team status from their kicker
CREATE POLICY "team_status_select_policy" ON public.team_status
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.teams t
            JOIN public.player p ON p.kicker_id = t.kicker_id
            WHERE t.id = team_status.team_id 
              AND p.user_id = auth.uid()
        )
    );

-- Team bounty history: Users can view from their kicker
CREATE POLICY "team_bounty_history_select_policy" ON public.team_bounty_history
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.teams t
            JOIN public.player p ON p.kicker_id = t.kicker_id
            WHERE t.id = team_bounty_history.claimer_team_id 
              AND p.user_id = auth.uid()
        )
    );

-- ============================================
-- ADD BOUNTY COLUMNS TO MATCHES TABLE
-- For storing team bounty at match time
-- ============================================
ALTER TABLE public.matches 
    ADD COLUMN IF NOT EXISTS bounty_team1_team INTEGER DEFAULT 0,
    ADD COLUMN IF NOT EXISTS bounty_team2_team INTEGER DEFAULT 0;

-- ============================================
-- UPDATE TEAM SEASON RANKINGS TO TRACK BOUNTY
-- bounty_claimed column already exists from 044 migration
-- ============================================

-- ============================================
-- FUNCTION: Update team status after match
-- Similar to update_player_status_after_match but for teams
-- ============================================
DROP FUNCTION IF EXISTS public.update_team_status_after_match(BIGINT, BIGINT, BOOLEAN, INT);

CREATE OR REPLACE FUNCTION public.update_team_status_after_match(
    p_team_id BIGINT,
    p_match_id BIGINT,
    p_is_winner BOOLEAN,
    p_opponent_team_id BIGINT
)
RETURNS TABLE (
    bounty_claimed INT,
    bounty_victim_id BIGINT,
    new_status TEXT[],
    streak INT,
    bounty_gained INT,
    old_streak INT
) AS $$
DECLARE
    v_current_streak INT;
    v_new_streak INT;
    v_current_bounty INT;
    v_new_bounty INT;
    v_threshold_bounty INT;
    v_bounty_gained INT := 0;
    v_active_statuses TEXT[];
    v_bounty_to_claim INT := 0;
    v_bounty_victim BIGINT := NULL;
    v_opponent_status RECORD;
    v_status_def RECORD;
BEGIN
    -- Get or create team status record
    INSERT INTO public.team_status (team_id, current_streak, current_bounty, active_statuses)
    VALUES (p_team_id, 0, 0, '{}')
    ON CONFLICT (team_id) DO NOTHING;
    
    -- Get current status
    SELECT current_streak, current_bounty, active_statuses
    INTO v_current_streak, v_current_bounty, v_active_statuses
    FROM public.team_status
    WHERE team_id = p_team_id;
    
    -- Calculate new streak
    IF p_is_winner THEN
        IF v_current_streak >= 0 THEN
            v_new_streak := v_current_streak + 1;
        ELSE
            v_new_streak := 1;  -- Reset from loss streak
        END IF;
    ELSE
        IF v_current_streak <= 0 THEN
            v_new_streak := v_current_streak - 1;
        ELSE
            v_new_streak := -1;  -- Reset from win streak
        END IF;
    END IF;
    
    -- ============================================
    -- BOUNTY CALCULATION
    -- Only add bounty when crossing a threshold (3, 5, 7, 10)
    -- Uses same status_definitions as player bounty
    -- ============================================
    IF p_is_winner AND v_new_streak >= 3 THEN
        -- Keep existing bounty as base (or 0 if coming from loss streak)
        IF v_current_streak >= 0 THEN
            v_new_bounty := v_current_bounty;
        ELSE
            v_new_bounty := 0;
        END IF;
        
        -- Check if we just crossed a threshold (3, 5, 7, or 10)
        SELECT bounty_per_streak INTO v_threshold_bounty
        FROM public.status_definitions
        WHERE type = 'streak' 
          AND (condition->>'streak_type') = 'win'
          AND (condition->>'min_streak')::int = v_new_streak
          AND v_current_streak < v_new_streak;
        
        -- Add threshold bounty if we crossed one
        IF v_threshold_bounty IS NOT NULL AND v_threshold_bounty > 0 THEN
            v_new_bounty := v_new_bounty + v_threshold_bounty;
            v_bounty_gained := v_threshold_bounty;
        END IF;
    ELSE
        -- Not on a win streak of 3+, bounty is 0
        v_new_bounty := 0;
    END IF;
    
    -- Check if we need to claim bounty from opponent team (if we won and broke their streak)
    IF p_is_winner AND p_opponent_team_id IS NOT NULL THEN
        SELECT ts.team_id, ts.current_streak, ts.current_bounty
        INTO v_opponent_status
        FROM public.team_status ts
        WHERE ts.team_id = p_opponent_team_id
          AND ts.current_streak >= 3;
        
        IF v_opponent_status IS NOT NULL AND v_opponent_status.current_bounty > 0 THEN
            v_bounty_to_claim := v_opponent_status.current_bounty;
            v_bounty_victim := v_opponent_status.team_id;
            
            -- Record bounty claim in history
            INSERT INTO public.team_bounty_history (claimer_team_id, victim_team_id, match_id, streak_broken, bounty_amount)
            VALUES (p_team_id, v_opponent_status.team_id, p_match_id, v_opponent_status.current_streak, v_opponent_status.current_bounty);
        END IF;
    END IF;
    
    -- Determine active statuses based on new streak
    v_active_statuses := '{}';
    
    FOR v_status_def IN
        SELECT key, condition
        FROM public.status_definitions
        WHERE type = 'streak'
        ORDER BY priority DESC
    LOOP
        IF (v_status_def.condition->>'streak_type') = 'win' AND v_new_streak >= (v_status_def.condition->>'min_streak')::int THEN
            v_active_statuses := array_append(v_active_statuses, v_status_def.key);
        ELSIF (v_status_def.condition->>'streak_type') = 'loss' AND v_new_streak <= -(v_status_def.condition->>'min_streak')::int THEN
            v_active_statuses := array_append(v_active_statuses, v_status_def.key);
        END IF;
    END LOOP;
    
    -- Update team status
    UPDATE public.team_status
    SET current_streak = v_new_streak,
        current_bounty = v_new_bounty,
        active_statuses = v_active_statuses,
        last_match_id = p_match_id,
        updated_at = NOW()
    WHERE team_id = p_team_id;
    
    -- Return results
    bounty_claimed := v_bounty_to_claim;
    bounty_victim_id := v_bounty_victim;
    new_status := v_active_statuses;
    streak := v_new_streak;
    bounty_gained := v_bounty_gained;
    old_streak := v_current_streak;
    
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- FUNCTION: Get team bounty (for match display)
-- Returns current bounty for a team
-- ============================================
DROP FUNCTION IF EXISTS public.get_team_bounty_for_team(BIGINT);

CREATE OR REPLACE FUNCTION public.get_team_bounty_for_team(
    p_team_id BIGINT
)
RETURNS INT AS $$
DECLARE
    v_bounty INT;
BEGIN
    SELECT COALESCE(current_bounty, 0)
    INTO v_bounty
    FROM public.team_status
    WHERE team_id = p_team_id;
    
    RETURN COALESCE(v_bounty, 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- FUNCTION: Get player team stats
-- Aggregates wins, losses, bounty across all teams for a player
-- ============================================
DROP FUNCTION IF EXISTS public.get_player_team_stats(BIGINT, BIGINT);

CREATE OR REPLACE FUNCTION public.get_player_team_stats(
    p_player_id BIGINT,
    p_season_id BIGINT DEFAULT NULL
)
RETURNS TABLE (
    wins BIGINT,
    losses BIGINT,
    bounty_claimed BIGINT
) AS $$
BEGIN
    IF p_season_id IS NULL THEN
        -- All-time stats from teams table
        RETURN QUERY
        SELECT 
            COALESCE(SUM(t.wins), 0)::BIGINT AS wins,
            COALESCE(SUM(t.losses), 0)::BIGINT AS losses,
            0::BIGINT AS bounty_claimed  -- All-time bounty not tracked separately
        FROM public.teams t
        WHERE (t.player1_id = p_player_id OR t.player2_id = p_player_id);
    ELSE
        -- Season-specific stats from team_season_rankings
        RETURN QUERY
        SELECT 
            COALESCE(SUM(tsr.wins), 0)::BIGINT AS wins,
            COALESCE(SUM(tsr.losses), 0)::BIGINT AS losses,
            COALESCE(SUM(tsr.bounty_claimed), 0)::BIGINT AS bounty_claimed
        FROM public.teams t
        JOIN public.team_season_rankings tsr ON t.id = tsr.team_id AND tsr.season_id = p_season_id
        WHERE (t.player1_id = p_player_id OR t.player2_id = p_player_id);
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- FUNCTION: Update team season ranking with bounty
-- Extends existing function to include bounty_claimed
-- ============================================
DROP FUNCTION IF EXISTS public.update_team_season_ranking_with_bounty(BIGINT, BIGINT, INTEGER, BOOLEAN, INTEGER);

CREATE OR REPLACE FUNCTION public.update_team_season_ranking_with_bounty(
    p_team_id BIGINT,
    p_season_id BIGINT,
    p_mmr_change INTEGER,
    p_won BOOLEAN,
    p_bounty_claimed INTEGER DEFAULT 0
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Ensure ranking exists
    PERFORM public.get_or_create_team_season_ranking(p_team_id, p_season_id);
    
    -- Update the ranking
    UPDATE public.team_season_rankings
    SET 
        mmr = mmr + p_mmr_change,
        wins = CASE WHEN p_won THEN wins + 1 ELSE wins END,
        losses = CASE WHEN NOT p_won THEN losses + 1 ELSE losses END,
        bounty_claimed = bounty_claimed + p_bounty_claimed
    WHERE team_id = p_team_id AND season_id = p_season_id;
END;
$$;

-- ============================================
-- GRANTS
-- ============================================
GRANT SELECT ON public.team_status TO authenticated;
GRANT SELECT ON public.team_bounty_history TO authenticated;
GRANT EXECUTE ON FUNCTION public.update_team_status_after_match(BIGINT, BIGINT, BOOLEAN, BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.update_team_status_after_match(BIGINT, BIGINT, BOOLEAN, BIGINT) TO service_role;
GRANT EXECUTE ON FUNCTION public.get_team_bounty_for_team(BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_player_team_stats(BIGINT, BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION public.update_team_season_ranking_with_bounty(BIGINT, BIGINT, INTEGER, BOOLEAN, INTEGER) TO authenticated;
