-- Migration: Create player status system with bounties
-- Schema: public
SET search_path TO public;

-- ============================================
-- STATUS DEFINITIONS TABLE
-- Defines all possible status effects and their thresholds
-- ============================================
CREATE TABLE IF NOT EXISTS public.status_definitions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    key TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    description TEXT,
    -- Status type for categorization
    type TEXT NOT NULL CHECK (type IN ('streak', 'event', 'monthly', 'special')),
    -- Conditions for activation (JSONB for flexibility)
    condition JSONB NOT NULL,
    -- Bounty MMR bonus when this status' streak is broken
    bounty_per_streak INT DEFAULT 0,
    -- Maximum bounty cap (0 = no cap)
    bounty_cap INT DEFAULT 0,
    -- Priority for display (higher = more prominent)
    priority INT DEFAULT 0,
    -- Asset key matching STATUS_EFFECTS in Avatar.jsx
    asset_key TEXT NOT NULL,
    -- Duration in seconds (NULL = until condition changes)
    duration_seconds INT,
    -- Whether multiple instances can stack
    is_stackable BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================
-- PLAYER STATUS TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS public.player_status (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    player_id BIGINT NOT NULL REFERENCES public.player(id) ON DELETE CASCADE,
    gamemode TEXT NOT NULL CHECK (gamemode IN ('1on1', '2on2')),
    current_streak INT NOT NULL DEFAULT 0,
    current_bounty INT NOT NULL DEFAULT 0,
    active_statuses TEXT[] DEFAULT '{}',
    last_match_id BIGINT,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT player_status_unique UNIQUE (player_id, gamemode)
);

-- ============================================
-- PLAYER MONTHLY STATUS TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS public.player_monthly_status (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    player_id BIGINT NOT NULL REFERENCES public.player(id) ON DELETE CASCADE,
    gamemode TEXT NOT NULL CHECK (gamemode IN ('1on1', '2on2')),
    month TEXT NOT NULL,
    humiliated_count INT DEFAULT 0,
    dominator_count INT DEFAULT 0,
    comeback_count INT DEFAULT 0,
    underdog_count INT DEFAULT 0,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT player_monthly_status_unique UNIQUE (player_id, gamemode, month)
);

-- ============================================
-- BOUNTY HISTORY TABLE
-- ============================================
CREATE TABLE IF NOT EXISTS public.bounty_history (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    claimer_id BIGINT NOT NULL REFERENCES public.player(id) ON DELETE CASCADE,
    victim_id BIGINT NOT NULL REFERENCES public.player(id) ON DELETE CASCADE,
    match_id BIGINT NOT NULL,
    gamemode TEXT NOT NULL,
    streak_broken INT NOT NULL,
    bounty_amount INT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================
-- INDEXES
-- ============================================
CREATE INDEX IF NOT EXISTS idx_player_status_player ON public.player_status(player_id);
CREATE INDEX IF NOT EXISTS idx_player_status_updated ON public.player_status(updated_at);
CREATE INDEX IF NOT EXISTS idx_player_monthly_status_player ON public.player_monthly_status(player_id);
CREATE INDEX IF NOT EXISTS idx_player_monthly_status_month ON public.player_monthly_status(month);
CREATE INDEX IF NOT EXISTS idx_bounty_history_claimer ON public.bounty_history(claimer_id);
CREATE INDEX IF NOT EXISTS idx_bounty_history_victim ON public.bounty_history(victim_id);
CREATE INDEX IF NOT EXISTS idx_bounty_history_created ON public.bounty_history(created_at);

-- ============================================
-- RLS POLICIES
-- ============================================
ALTER TABLE public.status_definitions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.player_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.player_monthly_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bounty_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "status_definitions_select_policy" ON public.status_definitions
    FOR SELECT USING (true);

CREATE POLICY "player_status_select_policy" ON public.player_status
    FOR SELECT USING (true);

CREATE POLICY "player_monthly_status_select_policy" ON public.player_monthly_status
    FOR SELECT USING (true);

CREATE POLICY "bounty_history_select_policy" ON public.bounty_history
    FOR SELECT USING (true);

-- ============================================
-- INSERT DEFAULT STATUS DEFINITIONS
-- ============================================
INSERT INTO public.status_definitions (key, name, description, type, condition, bounty_per_streak, bounty_cap, priority, asset_key) VALUES
('warming_up', 'Warming Up', 'Won 3 games in a row', 'streak', 
 '{"streak_type": "win", "min_streak": 3}', 
 3, 0, 10, 'warmingUp'),

('hot_streak', 'Hot Streak', 'Won 5 games in a row', 'streak', 
 '{"streak_type": "win", "min_streak": 5}', 
 5, 0, 20, 'hotStreak'),

('on_fire', 'On Fire!', 'Won 7+ games in a row - Unstoppable!', 'streak', 
 '{"streak_type": "win", "min_streak": 7}', 
 8, 0, 30, 'onFire'),

('legendary', 'Legendary', 'Won 10+ games in a row - A living legend!', 'streak', 
 '{"streak_type": "win", "min_streak": 10}', 
 12, 100, 40, 'legendary'),

('cold', 'Cold', 'Lost 3 games in a row', 'streak', 
 '{"streak_type": "loss", "min_streak": 3}', 
 0, 0, 10, 'cold'),

('ice_cold', 'Ice Cold', 'Lost 5+ games in a row', 'streak', 
 '{"streak_type": "loss", "min_streak": 5}', 
 0, 0, 20, 'iceCold'),

('frozen', 'Frozen Solid', 'Lost 7+ games in a row - Needs help!', 'streak', 
 '{"streak_type": "loss", "min_streak": 7}', 
 0, 0, 30, 'frozen'),

('humiliated', 'Humiliated', 'Suffered a 0-10 defeat this month', 'monthly', 
 '{"event": "loss_10_0"}', 
 0, 0, 5, 'humiliated'),

('dominator', 'Dominator', 'Achieved a 10-0 victory this month', 'monthly', 
 '{"event": "win_10_0"}', 
 0, 0, 15, 'dominator'),

('comeback_king', 'Comeback King', 'Won after a 5+ loss streak', 'event', 
 '{"event": "comeback_after_loss_streak", "min_streak": 5}', 
 0, 0, 25, 'comeback'),

('underdog', 'Underdog', 'Beat an opponent with 200+ higher MMR', 'event', 
 '{"event": "beat_higher_mmr", "mmr_diff": 200}', 
 0, 0, 20, 'underdog'),

('giant_slayer', 'Giant Slayer', 'Beat the player with the highest current streak', 'event', 
 '{"event": "break_highest_streak"}', 
 0, 0, 35, 'giantSlayer');

-- ============================================
-- RPC: Update player status after match
-- ============================================
CREATE OR REPLACE FUNCTION public.update_player_status_after_match(
    p_player_id BIGINT,
    p_match_id BIGINT,
    p_gamemode TEXT,
    p_is_winner BOOLEAN,
    p_score_diff INT,
    p_own_mmr INT,
    p_opponent_mmr INT
)
RETURNS TABLE (
    bounty_claimed INT,
    bounty_victim_id BIGINT,
    new_status TEXT[],
    streak INT
) AS $$
DECLARE
    v_current_streak INT;
    v_new_streak INT;
    v_current_bounty INT;
    v_new_bounty INT;
    v_active_statuses TEXT[];
    v_bounty_to_claim INT := 0;
    v_bounty_victim BIGINT := NULL;
    v_opponent_status RECORD;
    v_status_def RECORD;
    v_month TEXT;
    v_was_on_loss_streak BOOLEAN := FALSE;
    v_loss_streak_before INT := 0;
BEGIN
    v_month := TO_CHAR(NOW(), 'YYYY-MM');
    
    INSERT INTO public.player_status (player_id, gamemode, current_streak, current_bounty, active_statuses)
    VALUES (p_player_id, p_gamemode, 0, 0, '{}')
    ON CONFLICT (player_id, gamemode) DO NOTHING;
    
    SELECT current_streak, current_bounty, active_statuses
    INTO v_current_streak, v_current_bounty, v_active_statuses
    FROM public.player_status
    WHERE player_id = p_player_id AND gamemode = p_gamemode;
    
    IF v_current_streak < 0 THEN
        v_was_on_loss_streak := TRUE;
        v_loss_streak_before := ABS(v_current_streak);
    END IF;
    
    IF p_is_winner THEN
        IF v_current_streak >= 0 THEN
            v_new_streak := v_current_streak + 1;
        ELSE
            v_new_streak := 1;
        END IF;
    ELSE
        IF v_current_streak <= 0 THEN
            v_new_streak := v_current_streak - 1;
        ELSE
            v_new_streak := -1;
        END IF;
    END IF;
    
    v_new_bounty := 0;
    IF v_new_streak >= 3 THEN
        SELECT bounty_per_streak INTO v_new_bounty
        FROM public.status_definitions
        WHERE type = 'streak' 
          AND (condition->>'streak_type') = 'win'
          AND (condition->>'min_streak')::int <= v_new_streak
        ORDER BY (condition->>'min_streak')::int DESC
        LIMIT 1;
        
        v_new_bounty := COALESCE(v_new_bounty, 0) * (v_new_streak - 2);
    END IF;
    
    IF p_is_winner THEN
        FOR v_opponent_status IN
            SELECT ps.player_id, ps.current_streak, ps.current_bounty
            FROM public.player_status ps
            JOIN public.matches m ON m.id = p_match_id
            WHERE ps.gamemode = p_gamemode
              AND ps.current_streak >= 3
              AND ps.player_id != p_player_id
              AND (
                  (p_gamemode = '1on1' AND ps.player_id IN (m.player1, m.player2))
                  OR
                  (p_gamemode = '2on2' AND ps.player_id IN (m.player1, m.player2, m.player3, m.player4))
              )
        LOOP
            v_bounty_to_claim := v_bounty_to_claim + v_opponent_status.current_bounty;
            v_bounty_victim := v_opponent_status.player_id;
            
            INSERT INTO public.bounty_history (claimer_id, victim_id, match_id, gamemode, streak_broken, bounty_amount)
            VALUES (p_player_id, v_opponent_status.player_id, p_match_id, p_gamemode, v_opponent_status.current_streak, v_opponent_status.current_bounty);
        END LOOP;
    END IF;
    
    v_active_statuses := '{}';
    
    FOR v_status_def IN
        SELECT key, condition
        FROM public.status_definitions
        WHERE type = 'streak'
        ORDER BY priority DESC
    LOOP
        IF (v_status_def.condition->>'streak_type') = 'win' AND v_new_streak >= (v_status_def.condition->>'min_streak')::int THEN
            v_active_statuses := array_append(v_active_statuses, v_status_def.key);
        ELSIF (v_status_def.condition->>'streak_type') = 'loss' AND v_new_streak <= -(v_status_def.condition->>'min_streak')::int THEN
            v_active_statuses := array_append(v_active_statuses, v_status_def.key);
        END IF;
    END LOOP;
    
    IF p_is_winner AND v_was_on_loss_streak AND v_loss_streak_before >= 5 THEN
        v_active_statuses := array_append(v_active_statuses, 'comeback_king');
        
        INSERT INTO public.player_monthly_status (player_id, gamemode, month, comeback_count)
        VALUES (p_player_id, p_gamemode, v_month, 1)
        ON CONFLICT (player_id, gamemode, month)
        DO UPDATE SET comeback_count = public.player_monthly_status.comeback_count + 1, updated_at = NOW();
    END IF;
    
    IF p_is_winner AND (p_opponent_mmr - p_own_mmr) >= 200 THEN
        v_active_statuses := array_append(v_active_statuses, 'underdog');
        
        INSERT INTO public.player_monthly_status (player_id, gamemode, month, underdog_count)
        VALUES (p_player_id, p_gamemode, v_month, 1)
        ON CONFLICT (player_id, gamemode, month)
        DO UPDATE SET underdog_count = public.player_monthly_status.underdog_count + 1, updated_at = NOW();
    END IF;
    
    IF p_is_winner AND p_score_diff = 10 THEN
        v_active_statuses := array_append(v_active_statuses, 'dominator');
        
        INSERT INTO public.player_monthly_status (player_id, gamemode, month, dominator_count)
        VALUES (p_player_id, p_gamemode, v_month, 1)
        ON CONFLICT (player_id, gamemode, month)
        DO UPDATE SET dominator_count = public.player_monthly_status.dominator_count + 1, updated_at = NOW();
    END IF;
    
    IF NOT p_is_winner AND p_score_diff = -10 THEN
        v_active_statuses := array_append(v_active_statuses, 'humiliated');
        
        INSERT INTO public.player_monthly_status (player_id, gamemode, month, humiliated_count)
        VALUES (p_player_id, p_gamemode, v_month, 1)
        ON CONFLICT (player_id, gamemode, month)
        DO UPDATE SET humiliated_count = public.player_monthly_status.humiliated_count + 1, updated_at = NOW();
    END IF;
    
    UPDATE public.player_status
    SET current_streak = v_new_streak,
        current_bounty = v_new_bounty,
        active_statuses = v_active_statuses,
        last_match_id = p_match_id,
        updated_at = NOW()
    WHERE player_id = p_player_id AND gamemode = p_gamemode;
    
    bounty_claimed := v_bounty_to_claim;
    bounty_victim_id := v_bounty_victim;
    new_status := v_active_statuses;
    streak := v_new_streak;
    
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- RPC: Get player status
-- ============================================
CREATE OR REPLACE FUNCTION public.get_player_status(p_player_id BIGINT)
RETURNS TABLE (
    gamemode TEXT,
    current_streak INT,
    current_bounty INT,
    active_statuses TEXT[],
    primary_status TEXT,
    updated_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ps.gamemode,
        ps.current_streak,
        ps.current_bounty,
        ps.active_statuses,
        (
            SELECT sd.asset_key
            FROM public.status_definitions sd
            WHERE sd.key = ANY(ps.active_statuses)
            ORDER BY sd.priority DESC
            LIMIT 1
        ) as primary_status,
        ps.updated_at
    FROM public.player_status ps
    WHERE ps.player_id = p_player_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- RPC: Get players with bounties
-- ============================================
CREATE OR REPLACE FUNCTION public.get_players_with_bounties(
    p_gamemode TEXT DEFAULT NULL,
    p_min_bounty INT DEFAULT 1
)
RETURNS TABLE (
    player_id BIGINT,
    player_name TEXT,
    player_avatar TEXT,
    gamemode TEXT,
    current_streak INT,
    current_bounty INT,
    active_statuses TEXT[],
    primary_status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ps.player_id,
        p.name as player_name,
        p.avatar as player_avatar,
        ps.gamemode,
        ps.current_streak,
        ps.current_bounty,
        ps.active_statuses,
        (
            SELECT sd.asset_key
            FROM public.status_definitions sd
            WHERE sd.key = ANY(ps.active_statuses)
            ORDER BY sd.priority DESC
            LIMIT 1
        ) as primary_status
    FROM public.player_status ps
    JOIN public.player p ON p.id = ps.player_id
    WHERE ps.current_bounty >= p_min_bounty
      AND (p_gamemode IS NULL OR ps.gamemode = p_gamemode)
    ORDER BY ps.current_bounty DESC, ps.current_streak DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- RPC: Get bounty leaderboard
-- ============================================
CREATE OR REPLACE FUNCTION public.get_bounty_leaderboard(
    p_limit INT DEFAULT 10,
    p_month TEXT DEFAULT NULL
)
RETURNS TABLE (
    player_id BIGINT,
    player_name TEXT,
    player_avatar TEXT,
    total_bounties_claimed INT,
    total_bounty_amount INT,
    biggest_bounty INT,
    biggest_streak_broken INT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        bh.claimer_id as player_id,
        p.name as player_name,
        p.avatar as player_avatar,
        COUNT(*)::INT as total_bounties_claimed,
        SUM(bh.bounty_amount)::INT as total_bounty_amount,
        MAX(bh.bounty_amount)::INT as biggest_bounty,
        MAX(bh.streak_broken)::INT as biggest_streak_broken
    FROM public.bounty_history bh
    JOIN public.player p ON p.id = bh.claimer_id
    WHERE (p_month IS NULL OR TO_CHAR(bh.created_at, 'YYYY-MM') = p_month)
    GROUP BY bh.claimer_id, p.name, p.avatar
    ORDER BY total_bounty_amount DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
