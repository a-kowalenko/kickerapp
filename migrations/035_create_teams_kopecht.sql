-- Migration: Create teams and team_invitations tables for permanent 2v2 teams (kopecht schema)
-- Teams have their own MMR separate from individual player MMR

SET search_path TO kopecht;

-- 1. Create teams table
CREATE TABLE IF NOT EXISTS kopecht.teams (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    logo_url TEXT,
    player1_id BIGINT NOT NULL REFERENCES kopecht.player(id) ON DELETE CASCADE,
    player2_id BIGINT NOT NULL REFERENCES kopecht.player(id) ON DELETE CASCADE,
    kicker_id BIGINT NOT NULL REFERENCES kopecht.kicker(id) ON DELETE CASCADE,
    status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'active', 'dissolved'
    mmr INTEGER NOT NULL DEFAULT 1000,
    wins INTEGER NOT NULL DEFAULT 0,
    losses INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    dissolved_at TIMESTAMPTZ,
    
    -- Team name must be unique within a kicker
    CONSTRAINT teams_name_kicker_unique UNIQUE(name, kicker_id),
    -- Players cannot be the same person
    CONSTRAINT teams_different_players CHECK (player1_id != player2_id)
);

-- Create indexes for teams
CREATE INDEX IF NOT EXISTS idx_teams_kicker_id ON kopecht.teams(kicker_id);
CREATE INDEX IF NOT EXISTS idx_teams_player1_id ON kopecht.teams(player1_id);
CREATE INDEX IF NOT EXISTS idx_teams_player2_id ON kopecht.teams(player2_id);
CREATE INDEX IF NOT EXISTS idx_teams_status ON kopecht.teams(status);
CREATE INDEX IF NOT EXISTS idx_teams_mmr ON kopecht.teams(mmr DESC);

-- 2. Create team_invitations table
CREATE TABLE IF NOT EXISTS kopecht.team_invitations (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    team_id BIGINT NOT NULL REFERENCES kopecht.teams(id) ON DELETE CASCADE,
    inviting_player_id BIGINT NOT NULL REFERENCES kopecht.player(id) ON DELETE CASCADE,
    invited_player_id BIGINT NOT NULL REFERENCES kopecht.player(id) ON DELETE CASCADE,
    status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'accepted', 'declined'
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    responded_at TIMESTAMPTZ,
    
    -- Cannot invite yourself
    CONSTRAINT team_invitations_different_players CHECK (inviting_player_id != invited_player_id)
);

-- Create indexes for team_invitations
CREATE INDEX IF NOT EXISTS idx_team_invitations_team_id ON kopecht.team_invitations(team_id);
CREATE INDEX IF NOT EXISTS idx_team_invitations_invited_player_id ON kopecht.team_invitations(invited_player_id);
CREATE INDEX IF NOT EXISTS idx_team_invitations_inviting_player_id ON kopecht.team_invitations(inviting_player_id);
CREATE INDEX IF NOT EXISTS idx_team_invitations_status ON kopecht.team_invitations(status);

-- 3. Add team columns to matches table
ALTER TABLE kopecht.matches 
    ADD COLUMN IF NOT EXISTS team1_id BIGINT REFERENCES kopecht.teams(id),
    ADD COLUMN IF NOT EXISTS team2_id BIGINT REFERENCES kopecht.teams(id);

-- Create indexes for team match lookups
CREATE INDEX IF NOT EXISTS idx_matches_team1_id ON kopecht.matches(team1_id);
CREATE INDEX IF NOT EXISTS idx_matches_team2_id ON kopecht.matches(team2_id);

-- 4. Enable Row Level Security
ALTER TABLE kopecht.teams ENABLE ROW LEVEL SECURITY;
ALTER TABLE kopecht.team_invitations ENABLE ROW LEVEL SECURITY;

-- 5. RLS Policies for teams

-- Users can view teams in their kickers
CREATE POLICY "Users can view teams in their kickers"
ON kopecht.teams FOR SELECT
USING (
    EXISTS (
        SELECT 1 FROM kopecht.player
        WHERE kopecht.player.kicker_id = kopecht.teams.kicker_id
        AND kopecht.player.user_id = auth.uid()
    )
);

-- Users can create teams if they are player1 (the creator)
CREATE POLICY "Users can create teams"
ON kopecht.teams FOR INSERT
WITH CHECK (
    EXISTS (
        SELECT 1 FROM kopecht.player
        WHERE kopecht.player.id = kopecht.teams.player1_id
        AND kopecht.player.user_id = auth.uid()
    )
);

-- Team members can update their team (name, logo)
CREATE POLICY "Team members can update team"
ON kopecht.teams FOR UPDATE
USING (
    EXISTS (
        SELECT 1 FROM kopecht.player
        WHERE (kopecht.player.id = kopecht.teams.player1_id OR kopecht.player.id = kopecht.teams.player2_id)
        AND kopecht.player.user_id = auth.uid()
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1 FROM kopecht.player
        WHERE (kopecht.player.id = kopecht.teams.player1_id OR kopecht.player.id = kopecht.teams.player2_id)
        AND kopecht.player.user_id = auth.uid()
    )
);

-- No delete policy - teams are dissolved, not deleted

-- 6. RLS Policies for team_invitations

-- Users can view their own invitations (sent or received)
CREATE POLICY "Users can view own invitations"
ON kopecht.team_invitations FOR SELECT
USING (
    EXISTS (
        SELECT 1 FROM kopecht.player
        WHERE (kopecht.player.id = kopecht.team_invitations.inviting_player_id 
               OR kopecht.player.id = kopecht.team_invitations.invited_player_id)
        AND kopecht.player.user_id = auth.uid()
    )
);

-- Users can create invitations if they are the inviting player
CREATE POLICY "Users can create invitations"
ON kopecht.team_invitations FOR INSERT
WITH CHECK (
    EXISTS (
        SELECT 1 FROM kopecht.player
        WHERE kopecht.player.id = kopecht.team_invitations.inviting_player_id
        AND kopecht.player.user_id = auth.uid()
    )
);

-- Invited users can update invitation status (accept/decline)
CREATE POLICY "Invited users can update invitation"
ON kopecht.team_invitations FOR UPDATE
USING (
    EXISTS (
        SELECT 1 FROM kopecht.player
        WHERE kopecht.player.id = kopecht.team_invitations.invited_player_id
        AND kopecht.player.user_id = auth.uid()
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1 FROM kopecht.player
        WHERE kopecht.player.id = kopecht.team_invitations.invited_player_id
        AND kopecht.player.user_id = auth.uid()
    )
);

-- Inviting users can delete pending invitations (cancel)
CREATE POLICY "Inviting users can delete pending invitations"
ON kopecht.team_invitations FOR DELETE
USING (
    kopecht.team_invitations.status = 'pending'
    AND EXISTS (
        SELECT 1 FROM kopecht.player
        WHERE kopecht.player.id = kopecht.team_invitations.inviting_player_id
        AND kopecht.player.user_id = auth.uid()
    )
);

-- 7. Add tables to realtime publication
ALTER PUBLICATION supabase_realtime ADD TABLE kopecht.teams;
ALTER PUBLICATION supabase_realtime ADD TABLE kopecht.team_invitations;

-- 8. RPC Function: Accept team invitation
CREATE OR REPLACE FUNCTION kopecht.accept_team_invitation(p_invitation_id BIGINT)
RETURNS JSON AS $$
DECLARE
    v_invitation RECORD;
    v_team RECORD;
    v_user_player_id BIGINT;
BEGIN
    -- Get current user's player ID
    SELECT id INTO v_user_player_id
    FROM kopecht.player
    WHERE user_id = auth.uid()
    LIMIT 1;
    
    IF v_user_player_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Player not found');
    END IF;
    
    -- Get invitation
    SELECT * INTO v_invitation
    FROM kopecht.team_invitations
    WHERE id = p_invitation_id;
    
    IF v_invitation IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Invitation not found');
    END IF;
    
    -- Check if user is the invited player
    IF v_invitation.invited_player_id != v_user_player_id THEN
        RETURN json_build_object('success', false, 'error', 'Not authorized');
    END IF;
    
    -- Check if invitation is still pending
    IF v_invitation.status != 'pending' THEN
        RETURN json_build_object('success', false, 'error', 'Invitation already responded to');
    END IF;
    
    -- Update invitation status
    UPDATE kopecht.team_invitations
    SET status = 'accepted', responded_at = NOW()
    WHERE id = p_invitation_id;
    
    -- Activate the team
    UPDATE kopecht.teams
    SET status = 'active'
    WHERE id = v_invitation.team_id;
    
    -- Get team info for response
    SELECT * INTO v_team
    FROM kopecht.teams
    WHERE id = v_invitation.team_id;
    
    RETURN json_build_object(
        'success', true, 
        'team_id', v_team.id,
        'team_name', v_team.name
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 9. RPC Function: Decline team invitation
CREATE OR REPLACE FUNCTION kopecht.decline_team_invitation(p_invitation_id BIGINT)
RETURNS JSON AS $$
DECLARE
    v_invitation RECORD;
    v_user_player_id BIGINT;
BEGIN
    -- Get current user's player ID
    SELECT id INTO v_user_player_id
    FROM kopecht.player
    WHERE user_id = auth.uid()
    LIMIT 1;
    
    IF v_user_player_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Player not found');
    END IF;
    
    -- Get invitation
    SELECT * INTO v_invitation
    FROM kopecht.team_invitations
    WHERE id = p_invitation_id;
    
    IF v_invitation IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Invitation not found');
    END IF;
    
    -- Check if user is the invited player
    IF v_invitation.invited_player_id != v_user_player_id THEN
        RETURN json_build_object('success', false, 'error', 'Not authorized');
    END IF;
    
    -- Check if invitation is still pending
    IF v_invitation.status != 'pending' THEN
        RETURN json_build_object('success', false, 'error', 'Invitation already responded to');
    END IF;
    
    -- Update invitation status
    UPDATE kopecht.team_invitations
    SET status = 'declined', responded_at = NOW()
    WHERE id = p_invitation_id;
    
    -- Delete the pending team (it was never activated)
    DELETE FROM kopecht.teams
    WHERE id = v_invitation.team_id AND status = 'pending';
    
    RETURN json_build_object('success', true);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 10. RPC Function: Dissolve team
CREATE OR REPLACE FUNCTION kopecht.dissolve_team(p_team_id BIGINT)
RETURNS JSON AS $$
DECLARE
    v_team RECORD;
    v_user_player_id BIGINT;
BEGIN
    -- Get team first to know which kicker it belongs to
    SELECT * INTO v_team
    FROM kopecht.teams
    WHERE id = p_team_id;
    
    IF v_team IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Team not found');
    END IF;
    
    -- Get current user's player ID for the team's kicker
    SELECT id INTO v_user_player_id
    FROM kopecht.player
    WHERE user_id = auth.uid() AND kicker_id = v_team.kicker_id
    LIMIT 1;
    
    IF v_user_player_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Player not found');
    END IF;
    
    -- Check if user is a team member
    IF v_team.player1_id != v_user_player_id AND v_team.player2_id != v_user_player_id THEN
        RETURN json_build_object('success', false, 'error', 'Not a team member');
    END IF;
    
    -- Check if team is active
    IF v_team.status != 'active' THEN
        RETURN json_build_object('success', false, 'error', 'Team is not active');
    END IF;
    
    -- Dissolve the team
    UPDATE kopecht.teams
    SET status = 'dissolved', dissolved_at = NOW()
    WHERE id = p_team_id;
    
    RETURN json_build_object('success', true, 'team_name', v_team.name);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 11. RPC Function: Create team with invitation
CREATE OR REPLACE FUNCTION kopecht.create_team_with_invitation(
    p_name VARCHAR(50),
    p_partner_player_id BIGINT,
    p_kicker_id BIGINT
)
RETURNS JSON AS $$
DECLARE
    v_user_player_id BIGINT;
    v_team_id BIGINT;
    v_invitation_id BIGINT;
BEGIN
    -- Get current user's player ID for this kicker
    SELECT id INTO v_user_player_id
    FROM kopecht.player
    WHERE user_id = auth.uid() AND kicker_id = p_kicker_id
    LIMIT 1;
    
    IF v_user_player_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Player not found in this kicker');
    END IF;
    
    -- Check partner exists in same kicker
    IF NOT EXISTS (SELECT 1 FROM kopecht.player WHERE id = p_partner_player_id AND kicker_id = p_kicker_id) THEN
        RETURN json_build_object('success', false, 'error', 'Partner not found in this kicker');
    END IF;
    
    -- Check if team name already exists in this kicker
    IF EXISTS (SELECT 1 FROM kopecht.teams WHERE name = p_name AND kicker_id = p_kicker_id AND status != 'dissolved') THEN
        RETURN json_build_object('success', false, 'error', 'Team name already exists');
    END IF;
    
    -- Create team with pending status
    INSERT INTO kopecht.teams (name, player1_id, player2_id, kicker_id, status)
    VALUES (p_name, v_user_player_id, p_partner_player_id, p_kicker_id, 'pending')
    RETURNING id INTO v_team_id;
    
    -- Create invitation
    INSERT INTO kopecht.team_invitations (team_id, inviting_player_id, invited_player_id)
    VALUES (v_team_id, v_user_player_id, p_partner_player_id)
    RETURNING id INTO v_invitation_id;
    
    RETURN json_build_object(
        'success', true,
        'team_id', v_team_id,
        'invitation_id', v_invitation_id
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 12. RPC Function: Update team MMR after match
CREATE OR REPLACE FUNCTION kopecht.update_team_mmr(
    p_team_id BIGINT,
    p_mmr_change INTEGER,
    p_won BOOLEAN
)
RETURNS VOID AS $$
BEGIN
    UPDATE kopecht.teams
    SET 
        mmr = mmr + p_mmr_change,
        wins = CASE WHEN p_won THEN wins + 1 ELSE wins END,
        losses = CASE WHEN NOT p_won THEN losses + 1 ELSE losses END
    WHERE id = p_team_id AND status = 'active';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 13. RPC Function: Get teams by kicker
CREATE OR REPLACE FUNCTION kopecht.get_teams_by_kicker(p_kicker_id BIGINT)
RETURNS TABLE (
    id BIGINT,
    name VARCHAR(50),
    logo_url TEXT,
    player1_id BIGINT,
    player1_name TEXT,
    player1_avatar TEXT,
    player2_id BIGINT,
    player2_name TEXT,
    player2_avatar TEXT,
    status TEXT,
    mmr INTEGER,
    wins INTEGER,
    losses INTEGER,
    created_at TIMESTAMPTZ,
    dissolved_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        t.id,
        t.name,
        t.logo_url,
        t.player1_id,
        p1.name AS player1_name,
        p1.avatar_url AS player1_avatar,
        t.player2_id,
        p2.name AS player2_name,
        p2.avatar_url AS player2_avatar,
        t.status,
        t.mmr,
        t.wins,
        t.losses,
        t.created_at,
        t.dissolved_at
    FROM kopecht.teams t
    JOIN kopecht.player p1 ON t.player1_id = p1.id
    JOIN kopecht.player p2 ON t.player2_id = p2.id
    WHERE t.kicker_id = p_kicker_id
    ORDER BY t.mmr DESC, t.wins DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 14. RPC Function: Get pending invitations for player
CREATE OR REPLACE FUNCTION kopecht.get_pending_team_invitations(p_player_id BIGINT)
RETURNS TABLE (
    invitation_id BIGINT,
    team_id BIGINT,
    team_name VARCHAR(50),
    inviting_player_id BIGINT,
    inviting_player_name TEXT,
    inviting_player_avatar TEXT,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ti.id AS invitation_id,
        t.id AS team_id,
        t.name AS team_name,
        ti.inviting_player_id,
        p.name AS inviting_player_name,
        p.avatar_url AS inviting_player_avatar,
        ti.created_at
    FROM kopecht.team_invitations ti
    JOIN kopecht.teams t ON ti.team_id = t.id
    JOIN kopecht.player p ON ti.inviting_player_id = p.id
    WHERE ti.invited_player_id = p_player_id
    AND ti.status = 'pending'
    ORDER BY ti.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
