-- Migration: Add match-specific comment read status tracking
-- Used for tracking which comments in a specific match have been read

-- 1. Create match_comment_read_status table
-- Tracks when a user last read comments for a specific match
CREATE TABLE IF NOT EXISTS match_comment_read_status (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    match_id BIGINT NOT NULL REFERENCES matches(id) ON DELETE CASCADE,
    last_read_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(user_id, match_id)
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_match_comment_read_status_user_id ON match_comment_read_status(user_id);
CREATE INDEX IF NOT EXISTS idx_match_comment_read_status_match_id ON match_comment_read_status(match_id);

-- 2. Enable Row Level Security
ALTER TABLE match_comment_read_status ENABLE ROW LEVEL SECURITY;

-- 3. RLS Policies

-- Users can view their own read status
CREATE POLICY "Users can view own match comment read status"
ON match_comment_read_status FOR SELECT
USING (auth.uid() = user_id);

-- Users can insert their own read status
CREATE POLICY "Users can insert own match comment read status"
ON match_comment_read_status FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- Users can update their own read status
CREATE POLICY "Users can update own match comment read status"
ON match_comment_read_status FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Users can delete their own read status
CREATE POLICY "Users can delete own match comment read status"
ON match_comment_read_status FOR DELETE
USING (auth.uid() = user_id);

-- 4. Create function to update last_read_at for a specific match
CREATE OR REPLACE FUNCTION update_match_comment_read_status(p_match_id BIGINT)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    INSERT INTO match_comment_read_status (user_id, match_id, last_read_at, updated_at)
    VALUES (auth.uid(), p_match_id, NOW(), NOW())
    ON CONFLICT (user_id, match_id)
    DO UPDATE SET 
        last_read_at = NOW(),
        updated_at = NOW();
END;
$$;

-- 5. Create function to get unread comment count for a specific match
CREATE OR REPLACE FUNCTION get_unread_match_comment_count(p_match_id BIGINT)
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_player_id BIGINT;
    v_kicker_id BIGINT;
    v_last_read_at TIMESTAMPTZ;
    v_count BIGINT;
BEGIN
    -- Get kicker_id from the match
    SELECT kicker_id INTO v_kicker_id
    FROM matches
    WHERE id = p_match_id;
    
    IF v_kicker_id IS NULL THEN
        RETURN 0;
    END IF;
    
    -- Get the player ID for this user in this kicker
    SELECT id INTO v_player_id
    FROM player
    WHERE user_id = auth.uid() AND kicker_id = v_kicker_id;
    
    IF v_player_id IS NULL THEN
        RETURN 0;
    END IF;
    
    -- Get last read timestamp for this specific match
    SELECT last_read_at INTO v_last_read_at
    FROM match_comment_read_status
    WHERE user_id = auth.uid() AND match_id = p_match_id;
    
    -- Count unread comments for this match only
    SELECT COUNT(*)::BIGINT INTO v_count
    FROM match_comments mc
    WHERE mc.match_id = p_match_id
        AND mc.created_at > COALESCE(v_last_read_at, '1970-01-01'::TIMESTAMPTZ)
        AND mc.player_id != v_player_id;  -- Don't count own comments
    
    RETURN COALESCE(v_count, 0);
END;
$$;

-- 6. Grant execute permissions
GRANT EXECUTE ON FUNCTION update_match_comment_read_status(BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION get_unread_match_comment_count(BIGINT) TO authenticated;
