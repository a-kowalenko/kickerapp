-- Migration: Create player status system with bounties
-- Schema: kopecht

-- ============================================
-- STATUS DEFINITIONS TABLE
-- Defines all possible status effects and their thresholds
-- ============================================
CREATE TABLE IF NOT EXISTS kopecht.status_definitions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    key TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    description TEXT,
    -- Status type for categorization
    type TEXT NOT NULL CHECK (type IN ('streak', 'event', 'monthly', 'special')),
    -- Conditions for activation (JSONB for flexibility)
    -- Example: {"streak_type": "win", "min_streak": 5, "gamemode": "1on1"}
    condition JSONB NOT NULL,
    -- Bounty MMR bonus when this status' streak is broken
    bounty_per_streak INT DEFAULT 0,
    -- Maximum bounty cap (0 = no cap)
    bounty_cap INT DEFAULT 0,
    -- Priority for display (higher = more prominent)
    priority INT DEFAULT 0,
    -- Asset key matching STATUS_EFFECTS in Avatar.jsx
    asset_key TEXT NOT NULL,
    -- Duration in seconds (NULL = until condition changes)
    duration_seconds INT,
    -- Whether multiple instances can stack
    is_stackable BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================
-- PLAYER STATUS TABLE
-- Tracks each player's current status effects and bounties
-- ============================================
CREATE TABLE IF NOT EXISTS kopecht.player_status (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    player_id BIGINT NOT NULL REFERENCES kopecht.player(id) ON DELETE CASCADE,
    -- Gamemode separation (1on1 and 2on2 have independent streaks)
    gamemode TEXT NOT NULL CHECK (gamemode IN ('1on1', '2on2')),
    -- Current streak (positive = wins, negative = losses)
    current_streak INT NOT NULL DEFAULT 0,
    -- Accumulated bounty from streak (in MMR)
    current_bounty INT NOT NULL DEFAULT 0,
    -- Active status effects (keys from status_definitions)
    active_statuses TEXT[] DEFAULT '{}',
    -- Last match that affected this status
    last_match_id BIGINT,
    -- Timestamps
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    -- One entry per player per gamemode
    CONSTRAINT player_status_unique UNIQUE (player_id, gamemode)
);

-- ============================================
-- PLAYER MONTHLY STATUS TABLE
-- Tracks monthly events like 10-0 losses/wins
-- ============================================
CREATE TABLE IF NOT EXISTS kopecht.player_monthly_status (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    player_id BIGINT NOT NULL REFERENCES kopecht.player(id) ON DELETE CASCADE,
    gamemode TEXT NOT NULL CHECK (gamemode IN ('1on1', '2on2')),
    -- Year and month (e.g., '2024-12')
    month TEXT NOT NULL,
    -- Events that occurred this month
    humiliated_count INT DEFAULT 0,  -- 0-10 losses
    dominator_count INT DEFAULT 0,   -- 10-0 wins
    comeback_count INT DEFAULT 0,    -- Wins after 5+ loss streak
    underdog_count INT DEFAULT 0,    -- Wins against 200+ higher MMR
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT player_monthly_status_unique UNIQUE (player_id, gamemode, month)
);

-- ============================================
-- BOUNTY HISTORY TABLE
-- Tracks bounty payouts for statistics/leaderboards
-- ============================================
CREATE TABLE IF NOT EXISTS kopecht.bounty_history (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- Player who claimed the bounty
    claimer_id BIGINT NOT NULL REFERENCES kopecht.player(id) ON DELETE CASCADE,
    -- Player whose streak was broken
    victim_id BIGINT NOT NULL REFERENCES kopecht.player(id) ON DELETE CASCADE,
    -- Match where the bounty was claimed
    match_id BIGINT NOT NULL,
    gamemode TEXT NOT NULL,
    -- The streak that was broken
    streak_broken INT NOT NULL,
    -- Bounty amount paid out
    bounty_amount INT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- ============================================
-- INDEXES
-- ============================================
CREATE INDEX IF NOT EXISTS idx_player_status_player ON kopecht.player_status(player_id);
CREATE INDEX IF NOT EXISTS idx_player_status_updated ON kopecht.player_status(updated_at);
CREATE INDEX IF NOT EXISTS idx_player_monthly_status_player ON kopecht.player_monthly_status(player_id);
CREATE INDEX IF NOT EXISTS idx_player_monthly_status_month ON kopecht.player_monthly_status(month);
CREATE INDEX IF NOT EXISTS idx_bounty_history_claimer ON kopecht.bounty_history(claimer_id);
CREATE INDEX IF NOT EXISTS idx_bounty_history_victim ON kopecht.bounty_history(victim_id);
CREATE INDEX IF NOT EXISTS idx_bounty_history_created ON kopecht.bounty_history(created_at);

-- ============================================
-- RLS POLICIES
-- ============================================
ALTER TABLE kopecht.status_definitions ENABLE ROW LEVEL SECURITY;
ALTER TABLE kopecht.player_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE kopecht.player_monthly_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE kopecht.bounty_history ENABLE ROW LEVEL SECURITY;

-- Status definitions: Everyone can read
CREATE POLICY "status_definitions_select_policy" ON kopecht.status_definitions
    FOR SELECT USING (true);

-- Player status: Everyone can read
CREATE POLICY "player_status_select_policy" ON kopecht.player_status
    FOR SELECT USING (true);

-- Player monthly status: Everyone can read
CREATE POLICY "player_monthly_status_select_policy" ON kopecht.player_monthly_status
    FOR SELECT USING (true);

-- Bounty history: Everyone can read
CREATE POLICY "bounty_history_select_policy" ON kopecht.bounty_history
    FOR SELECT USING (true);

-- ============================================
-- INSERT DEFAULT STATUS DEFINITIONS
-- ============================================
INSERT INTO kopecht.status_definitions (key, name, description, type, condition, bounty_per_streak, bounty_cap, priority, asset_key) VALUES
-- Win streak statuses
('warming_up', 'Warming Up', 'Won 3 games in a row', 'streak', 
 '{"streak_type": "win", "min_streak": 3}', 
 3, 0, 10, 'warmingUp'),

('hot_streak', 'Hot Streak', 'Won 5 games in a row', 'streak', 
 '{"streak_type": "win", "min_streak": 5}', 
 5, 0, 20, 'hotStreak'),

('on_fire', 'On Fire!', 'Won 7+ games in a row - Unstoppable!', 'streak', 
 '{"streak_type": "win", "min_streak": 7}', 
 8, 0, 30, 'onFire'),

('legendary', 'Legendary', 'Won 10+ games in a row - A living legend!', 'streak', 
 '{"streak_type": "win", "min_streak": 10}', 
 12, 100, 40, 'legendary'),

-- Loss streak statuses
('cold', 'Cold', 'Lost 3 games in a row', 'streak', 
 '{"streak_type": "loss", "min_streak": 3}', 
 0, 0, 10, 'cold'),

('ice_cold', 'Ice Cold', 'Lost 5+ games in a row', 'streak', 
 '{"streak_type": "loss", "min_streak": 5}', 
 0, 0, 20, 'iceCold'),

('frozen', 'Frozen Solid', 'Lost 7+ games in a row - Needs help!', 'streak', 
 '{"streak_type": "loss", "min_streak": 7}', 
 0, 0, 30, 'frozen'),

-- Monthly event statuses
('humiliated', 'Humiliated', 'Suffered a 0-10 defeat this month', 'monthly', 
 '{"event": "loss_10_0"}', 
 0, 0, 5, 'humiliated'),

('dominator', 'Dominator', 'Achieved a 10-0 victory this month', 'monthly', 
 '{"event": "win_10_0"}', 
 0, 0, 15, 'dominator'),

-- Special event statuses
('comeback_king', 'Comeback King', 'Won after a 5+ loss streak', 'event', 
 '{"event": "comeback_after_loss_streak", "min_streak": 5}', 
 0, 0, 25, 'comeback'),

('underdog', 'Underdog', 'Beat an opponent with 200+ higher MMR', 'event', 
 '{"event": "beat_higher_mmr", "mmr_diff": 200}', 
 0, 0, 20, 'underdog'),

('giant_slayer', 'Giant Slayer', 'Beat the player with the highest current streak', 'event', 
 '{"event": "break_highest_streak"}', 
 0, 0, 35, 'giantSlayer');

-- ============================================
-- RPC: Update player status after match
-- Called from match-ended flow
-- ============================================
CREATE OR REPLACE FUNCTION kopecht.update_player_status_after_match(
    p_player_id BIGINT,
    p_match_id BIGINT,
    p_gamemode TEXT,
    p_is_winner BOOLEAN,
    p_score_diff INT,  -- Positive means player's team won by this margin
    p_own_mmr INT,
    p_opponent_mmr INT
)
RETURNS TABLE (
    bounty_claimed INT,
    bounty_victim_id BIGINT,
    new_status TEXT[],
    streak INT
) AS $$
DECLARE
    v_current_streak INT;
    v_new_streak INT;
    v_current_bounty INT;
    v_new_bounty INT;
    v_active_statuses TEXT[];
    v_bounty_to_claim INT := 0;
    v_bounty_victim BIGINT := NULL;
    v_opponent_status RECORD;
    v_status_def RECORD;
    v_month TEXT;
    v_was_on_loss_streak BOOLEAN := FALSE;
    v_loss_streak_before INT := 0;
BEGIN
    -- Get current month for monthly events
    v_month := TO_CHAR(NOW(), 'YYYY-MM');
    
    -- Get or create player status record
    INSERT INTO kopecht.player_status (player_id, gamemode, current_streak, current_bounty, active_statuses)
    VALUES (p_player_id, p_gamemode, 0, 0, '{}')
    ON CONFLICT (player_id, gamemode) DO NOTHING;
    
    -- Get current status
    SELECT current_streak, current_bounty, active_statuses
    INTO v_current_streak, v_current_bounty, v_active_statuses
    FROM kopecht.player_status
    WHERE player_id = p_player_id AND gamemode = p_gamemode;
    
    -- Track if player was on a loss streak (for comeback detection)
    IF v_current_streak < 0 THEN
        v_was_on_loss_streak := TRUE;
        v_loss_streak_before := ABS(v_current_streak);
    END IF;
    
    -- Calculate new streak
    IF p_is_winner THEN
        IF v_current_streak >= 0 THEN
            v_new_streak := v_current_streak + 1;
        ELSE
            v_new_streak := 1;  -- Reset from loss streak
        END IF;
    ELSE
        IF v_current_streak <= 0 THEN
            v_new_streak := v_current_streak - 1;
        ELSE
            v_new_streak := -1;  -- Reset from win streak
        END IF;
    END IF;
    
    -- Calculate new bounty (only for win streaks)
    v_new_bounty := 0;
    IF v_new_streak >= 3 THEN
        -- Find applicable status definition for bounty calculation
        SELECT bounty_per_streak INTO v_new_bounty
        FROM kopecht.status_definitions
        WHERE type = 'streak' 
          AND (condition->>'streak_type') = 'win'
          AND (condition->>'min_streak')::int <= v_new_streak
        ORDER BY (condition->>'min_streak')::int DESC
        LIMIT 1;
        
        -- Add bounty: base + additional per win in streak
        v_new_bounty := COALESCE(v_new_bounty, 0) * (v_new_streak - 2);
    END IF;
    
    -- Check if we need to claim bounty from opponent (if we won and broke their streak)
    IF p_is_winner THEN
        -- Find opponent(s) from this match and check their status
        FOR v_opponent_status IN
            SELECT ps.player_id, ps.current_streak, ps.current_bounty
            FROM kopecht.player_status ps
            JOIN kopecht.matches m ON m.id = p_match_id
            WHERE ps.gamemode = p_gamemode
              AND ps.current_streak >= 3  -- Only if they had a win streak
              AND ps.player_id != p_player_id
              AND (
                  (p_gamemode = '1on1' AND ps.player_id IN (m.player1, m.player2))
                  OR
                  (p_gamemode = '2on2' AND ps.player_id IN (m.player1, m.player2, m.player3, m.player4))
              )
        LOOP
            -- Claim their bounty
            v_bounty_to_claim := v_bounty_to_claim + v_opponent_status.current_bounty;
            v_bounty_victim := v_opponent_status.player_id;
            
            -- Record bounty claim
            INSERT INTO kopecht.bounty_history (claimer_id, victim_id, match_id, gamemode, streak_broken, bounty_amount)
            VALUES (p_player_id, v_opponent_status.player_id, p_match_id, p_gamemode, v_opponent_status.current_streak, v_opponent_status.current_bounty);
        END LOOP;
    END IF;
    
    -- Determine active statuses based on new streak
    v_active_statuses := '{}';
    
    FOR v_status_def IN
        SELECT key, condition
        FROM kopecht.status_definitions
        WHERE type = 'streak'
        ORDER BY priority DESC
    LOOP
        IF (v_status_def.condition->>'streak_type') = 'win' AND v_new_streak >= (v_status_def.condition->>'min_streak')::int THEN
            v_active_statuses := array_append(v_active_statuses, v_status_def.key);
        ELSIF (v_status_def.condition->>'streak_type') = 'loss' AND v_new_streak <= -(v_status_def.condition->>'min_streak')::int THEN
            v_active_statuses := array_append(v_active_statuses, v_status_def.key);
        END IF;
    END LOOP;
    
    -- Check for special events
    
    -- Comeback King: Won after 5+ loss streak
    IF p_is_winner AND v_was_on_loss_streak AND v_loss_streak_before >= 5 THEN
        v_active_statuses := array_append(v_active_statuses, 'comeback_king');
        
        -- Update monthly stats
        INSERT INTO kopecht.player_monthly_status (player_id, gamemode, month, comeback_count)
        VALUES (p_player_id, p_gamemode, v_month, 1)
        ON CONFLICT (player_id, gamemode, month)
        DO UPDATE SET comeback_count = kopecht.player_monthly_status.comeback_count + 1, updated_at = NOW();
    END IF;
    
    -- Underdog: Beat opponent with 200+ higher MMR
    IF p_is_winner AND (p_opponent_mmr - p_own_mmr) >= 200 THEN
        v_active_statuses := array_append(v_active_statuses, 'underdog');
        
        -- Update monthly stats
        INSERT INTO kopecht.player_monthly_status (player_id, gamemode, month, underdog_count)
        VALUES (p_player_id, p_gamemode, v_month, 1)
        ON CONFLICT (player_id, gamemode, month)
        DO UPDATE SET underdog_count = kopecht.player_monthly_status.underdog_count + 1, updated_at = NOW();
    END IF;
    
    -- Dominator: 10-0 win
    IF p_is_winner AND p_score_diff = 10 THEN
        v_active_statuses := array_append(v_active_statuses, 'dominator');
        
        -- Update monthly stats
        INSERT INTO kopecht.player_monthly_status (player_id, gamemode, month, dominator_count)
        VALUES (p_player_id, p_gamemode, v_month, 1)
        ON CONFLICT (player_id, gamemode, month)
        DO UPDATE SET dominator_count = kopecht.player_monthly_status.dominator_count + 1, updated_at = NOW();
    END IF;
    
    -- Humiliated: 0-10 loss
    IF NOT p_is_winner AND p_score_diff = -10 THEN
        v_active_statuses := array_append(v_active_statuses, 'humiliated');
        
        -- Update monthly stats
        INSERT INTO kopecht.player_monthly_status (player_id, gamemode, month, humiliated_count)
        VALUES (p_player_id, p_gamemode, v_month, 1)
        ON CONFLICT (player_id, gamemode, month)
        DO UPDATE SET humiliated_count = kopecht.player_monthly_status.humiliated_count + 1, updated_at = NOW();
    END IF;
    
    -- Update player status
    UPDATE kopecht.player_status
    SET current_streak = v_new_streak,
        current_bounty = v_new_bounty,
        active_statuses = v_active_statuses,
        last_match_id = p_match_id,
        updated_at = NOW()
    WHERE player_id = p_player_id AND gamemode = p_gamemode;
    
    -- Return results
    bounty_claimed := v_bounty_to_claim;
    bounty_victim_id := v_bounty_victim;
    new_status := v_active_statuses;
    streak := v_new_streak;
    
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- RPC: Get player status
-- Returns current status for a player
-- ============================================
CREATE OR REPLACE FUNCTION kopecht.get_player_status(p_player_id BIGINT)
RETURNS TABLE (
    gamemode TEXT,
    current_streak INT,
    current_bounty INT,
    active_statuses TEXT[],
    primary_status TEXT,
    updated_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ps.gamemode,
        ps.current_streak,
        ps.current_bounty,
        ps.active_statuses,
        -- Primary status is the highest priority active status
        (
            SELECT sd.asset_key
            FROM kopecht.status_definitions sd
            WHERE sd.key = ANY(ps.active_statuses)
            ORDER BY sd.priority DESC
            LIMIT 1
        ) as primary_status,
        ps.updated_at
    FROM kopecht.player_status ps
    WHERE ps.player_id = p_player_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- RPC: Get players with active bounties
-- For bounty leaderboard / hunt targets
-- ============================================
CREATE OR REPLACE FUNCTION kopecht.get_players_with_bounties(
    p_gamemode TEXT DEFAULT NULL,
    p_min_bounty INT DEFAULT 1
)
RETURNS TABLE (
    player_id BIGINT,
    player_name TEXT,
    player_avatar TEXT,
    gamemode TEXT,
    current_streak INT,
    current_bounty INT,
    active_statuses TEXT[],
    primary_status TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ps.player_id,
        p.name as player_name,
        p.avatar as player_avatar,
        ps.gamemode,
        ps.current_streak,
        ps.current_bounty,
        ps.active_statuses,
        (
            SELECT sd.asset_key
            FROM kopecht.status_definitions sd
            WHERE sd.key = ANY(ps.active_statuses)
            ORDER BY sd.priority DESC
            LIMIT 1
        ) as primary_status
    FROM kopecht.player_status ps
    JOIN kopecht.player p ON p.id = ps.player_id
    WHERE ps.current_bounty >= p_min_bounty
      AND (p_gamemode IS NULL OR ps.gamemode = p_gamemode)
    ORDER BY ps.current_bounty DESC, ps.current_streak DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================
-- RPC: Get bounty leaderboard (top bounty hunters)
-- ============================================
CREATE OR REPLACE FUNCTION kopecht.get_bounty_leaderboard(
    p_limit INT DEFAULT 10,
    p_month TEXT DEFAULT NULL  -- Format: 'YYYY-MM', NULL for all time
)
RETURNS TABLE (
    player_id BIGINT,
    player_name TEXT,
    player_avatar TEXT,
    total_bounties_claimed INT,
    total_bounty_amount INT,
    biggest_bounty INT,
    biggest_streak_broken INT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        bh.claimer_id as player_id,
        p.name as player_name,
        p.avatar as player_avatar,
        COUNT(*)::INT as total_bounties_claimed,
        SUM(bh.bounty_amount)::INT as total_bounty_amount,
        MAX(bh.bounty_amount)::INT as biggest_bounty,
        MAX(bh.streak_broken)::INT as biggest_streak_broken
    FROM kopecht.bounty_history bh
    JOIN kopecht.player p ON p.id = bh.claimer_id
    WHERE (p_month IS NULL OR TO_CHAR(bh.created_at, 'YYYY-MM') = p_month)
    GROUP BY bh.claimer_id, p.name, p.avatar
    ORDER BY total_bounty_amount DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
