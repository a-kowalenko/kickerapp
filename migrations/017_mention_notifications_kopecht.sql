-- Migration: Add mention notifications system (kopecht schema)
-- Tracks @mentions in comments and chat messages for notification bell feature

-- 1. Create mention_notifications table
CREATE TABLE IF NOT EXISTS kopecht.mention_notifications (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    type VARCHAR(20) NOT NULL CHECK (type IN ('comment', 'chat')),
    source_id BIGINT NOT NULL,
    match_id BIGINT REFERENCES kopecht.matches(id) ON DELETE CASCADE,
    kicker_id BIGINT NOT NULL REFERENCES kopecht.kicker(id) ON DELETE CASCADE,
    sender_player_id BIGINT NOT NULL REFERENCES kopecht.player(id) ON DELETE CASCADE,
    content_preview TEXT NOT NULL,
    is_read BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create indexes for efficient querying
CREATE INDEX IF NOT EXISTS idx_mention_notifications_user_id ON kopecht.mention_notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_mention_notifications_user_unread ON kopecht.mention_notifications(user_id, is_read) WHERE is_read = FALSE;
CREATE INDEX IF NOT EXISTS idx_mention_notifications_created_at ON kopecht.mention_notifications(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_mention_notifications_kicker_id ON kopecht.mention_notifications(kicker_id);

-- 2. Enable Row Level Security
ALTER TABLE kopecht.mention_notifications ENABLE ROW LEVEL SECURITY;

-- Enable REPLICA IDENTITY FULL for realtime subscriptions with filters
ALTER TABLE kopecht.mention_notifications REPLICA IDENTITY FULL;

-- 3. RLS Policies

-- Users can view their own notifications
CREATE POLICY "Users can view own mention notifications"
ON kopecht.mention_notifications FOR SELECT
USING (auth.uid() = user_id);

-- Users can update their own notifications (mark as read)
CREATE POLICY "Users can update own mention notifications"
ON kopecht.mention_notifications FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Users can delete their own notifications
CREATE POLICY "Users can delete own mention notifications"
ON kopecht.mention_notifications FOR DELETE
USING (auth.uid() = user_id);

-- System can insert notifications (via trigger with SECURITY DEFINER)
-- No INSERT policy needed as triggers run with SECURITY DEFINER

-- 4. Function to get paginated notifications with related data
CREATE OR REPLACE FUNCTION kopecht.get_mention_notifications(p_limit INT DEFAULT 50, p_offset INT DEFAULT 0)
RETURNS TABLE (
    id BIGINT,
    type VARCHAR(20),
    source_id BIGINT,
    match_id BIGINT,
    kicker_id BIGINT,
    kicker_name TEXT,
    sender_player_id BIGINT,
    sender_player_name TEXT,
    sender_avatar TEXT,
    content_preview TEXT,
    is_read BOOLEAN,
    created_at TIMESTAMPTZ,
    match_info JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        mn.id,
        mn.type,
        mn.source_id,
        mn.match_id,
        mn.kicker_id,
        k.name AS kicker_name,
        mn.sender_player_id,
        p.name AS sender_player_name,
        p.avatar AS sender_avatar,
        mn.content_preview,
        mn.is_read,
        mn.created_at,
        CASE 
            WHEN mn.match_id IS NOT NULL THEN
                jsonb_build_object(
                    'id', m.id,
                    'player1_name', p1.name,
                    'player2_name', p2.name,
                    'player3_name', p3.name,
                    'player4_name', p4.name,
                    'scoreTeam1', m."scoreTeam1",
                    'scoreTeam2', m."scoreTeam2"
                )
            ELSE NULL
        END AS match_info
    FROM kopecht.mention_notifications mn
    JOIN kopecht.kicker k ON k.id = mn.kicker_id
    JOIN kopecht.player p ON p.id = mn.sender_player_id
    LEFT JOIN kopecht.matches m ON m.id = mn.match_id
    LEFT JOIN kopecht.player p1 ON p1.id = m.player1
    LEFT JOIN kopecht.player p2 ON p2.id = m.player2
    LEFT JOIN kopecht.player p3 ON p3.id = m.player3
    LEFT JOIN kopecht.player p4 ON p4.id = m.player4
    WHERE mn.user_id = auth.uid()
    ORDER BY mn.created_at DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;

-- 5. Function to get unread mention count
CREATE OR REPLACE FUNCTION kopecht.get_unread_mention_count()
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_count BIGINT;
BEGIN
    SELECT COUNT(*)::BIGINT INTO v_count
    FROM kopecht.mention_notifications
    WHERE user_id = auth.uid() AND is_read = FALSE;
    
    RETURN COALESCE(v_count, 0);
END;
$$;

-- 6. Function to mark single notification as read
CREATE OR REPLACE FUNCTION kopecht.mark_mention_as_read(p_notification_id BIGINT)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    UPDATE kopecht.mention_notifications
    SET is_read = TRUE
    WHERE id = p_notification_id AND user_id = auth.uid();
END;
$$;

-- 7. Function to mark all notifications as read
CREATE OR REPLACE FUNCTION kopecht.mark_all_mentions_as_read()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    UPDATE kopecht.mention_notifications
    SET is_read = TRUE
    WHERE user_id = auth.uid() AND is_read = FALSE;
END;
$$;

-- 8. Helper function to parse mentions and create notifications
CREATE OR REPLACE FUNCTION kopecht.create_mention_notifications(
    p_content TEXT,
    p_type VARCHAR(20),
    p_source_id BIGINT,
    p_match_id BIGINT,
    p_kicker_id BIGINT,
    p_sender_player_id BIGINT
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_mentioned_player_id BIGINT;
    v_mentioned_user_id UUID;
    v_content_preview TEXT;
    v_player_record RECORD;
BEGIN
    -- Truncate content for preview (max 100 chars)
    v_content_preview := LEFT(p_content, 100);
    IF LENGTH(p_content) > 100 THEN
        v_content_preview := v_content_preview || '...';
    END IF;
    
    -- Check for @everyone mention
    IF p_content LIKE '%@everyone%' THEN
        -- Insert notification for all players in the kicker (except sender)
        FOR v_player_record IN 
            SELECT pl.id, pl.user_id 
            FROM kopecht.player pl 
            WHERE pl.kicker_id = p_kicker_id 
              AND pl.id != p_sender_player_id
              AND pl.user_id IS NOT NULL
        LOOP
            INSERT INTO kopecht.mention_notifications (
                user_id, type, source_id, match_id, kicker_id, 
                sender_player_id, content_preview, is_read, created_at
            )
            VALUES (
                v_player_record.user_id, p_type, p_source_id, p_match_id, p_kicker_id,
                p_sender_player_id, v_content_preview, FALSE, NOW()
            )
            ON CONFLICT DO NOTHING;
        END LOOP;
    END IF;
    
    -- Parse individual @[name](player_id) mentions using regex
    -- Pattern: @[any text](digits)
    FOR v_mentioned_player_id IN 
        SELECT (regexp_matches(p_content, '@\[[^\]]+\]\((\d+)\)', 'g'))[1]::BIGINT
    LOOP
        -- Skip if mentioning self
        IF v_mentioned_player_id = p_sender_player_id THEN
            CONTINUE;
        END IF;
        
        -- Get user_id from player
        SELECT user_id INTO v_mentioned_user_id
        FROM kopecht.player
        WHERE id = v_mentioned_player_id;
        
        -- Skip if player has no user_id
        IF v_mentioned_user_id IS NULL THEN
            CONTINUE;
        END IF;
        
        -- Insert notification (avoid duplicates with ON CONFLICT DO NOTHING)
        INSERT INTO kopecht.mention_notifications (
            user_id, type, source_id, match_id, kicker_id,
            sender_player_id, content_preview, is_read, created_at
        )
        VALUES (
            v_mentioned_user_id, p_type, p_source_id, p_match_id, p_kicker_id,
            p_sender_player_id, v_content_preview, FALSE, NOW()
        )
        ON CONFLICT DO NOTHING;
    END LOOP;
END;
$$;

-- 9. Trigger function for match_comments
CREATE OR REPLACE FUNCTION kopecht.trigger_create_comment_mention_notifications()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    PERFORM kopecht.create_mention_notifications(
        NEW.content,
        'comment',
        NEW.id,
        NEW.match_id,
        NEW.kicker_id,
        NEW.player_id
    );
    RETURN NEW;
END;
$$;

-- 10. Trigger function for chat_messages
CREATE OR REPLACE FUNCTION kopecht.trigger_create_chat_mention_notifications()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    PERFORM kopecht.create_mention_notifications(
        NEW.content,
        'chat',
        NEW.id,
        NULL,  -- chat messages don't have match_id
        NEW.kicker_id,
        NEW.player_id
    );
    RETURN NEW;
END;
$$;

-- 11. Create triggers on match_comments and chat_messages
DROP TRIGGER IF EXISTS trigger_comment_mentions ON kopecht.match_comments;
CREATE TRIGGER trigger_comment_mentions
    AFTER INSERT ON kopecht.match_comments
    FOR EACH ROW
    EXECUTE FUNCTION kopecht.trigger_create_comment_mention_notifications();

DROP TRIGGER IF EXISTS trigger_chat_mentions ON kopecht.chat_messages;
CREATE TRIGGER trigger_chat_mentions
    AFTER INSERT ON kopecht.chat_messages
    FOR EACH ROW
    EXECUTE FUNCTION kopecht.trigger_create_chat_mention_notifications();

-- 12. Grant execute permissions
GRANT EXECUTE ON FUNCTION kopecht.get_mention_notifications(INT, INT) TO authenticated;
GRANT EXECUTE ON FUNCTION kopecht.get_unread_mention_count() TO authenticated;
GRANT EXECUTE ON FUNCTION kopecht.mark_mention_as_read(BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION kopecht.mark_all_mentions_as_read() TO authenticated;

-- 13. Migrate historical mentions from match_comments
INSERT INTO kopecht.mention_notifications (user_id, type, source_id, match_id, kicker_id, sender_player_id, content_preview, is_read, created_at)
SELECT DISTINCT
    p_mentioned.user_id,
    'comment',
    mc.id,
    mc.match_id,
    mc.kicker_id,
    mc.player_id,
    LEFT(mc.content, 100) || CASE WHEN LENGTH(mc.content) > 100 THEN '...' ELSE '' END,
    TRUE,  -- Mark historical as read
    mc.created_at
FROM kopecht.match_comments mc
CROSS JOIN LATERAL (
    SELECT (regexp_matches(mc.content, '@\[[^\]]+\]\((\d+)\)', 'g'))[1]::BIGINT AS mentioned_player_id
) mentions
JOIN kopecht.player p_mentioned ON p_mentioned.id = mentions.mentioned_player_id
WHERE p_mentioned.user_id IS NOT NULL
  AND p_mentioned.id != mc.player_id
ON CONFLICT DO NOTHING;

-- 14. Migrate historical @everyone mentions from match_comments
INSERT INTO kopecht.mention_notifications (user_id, type, source_id, match_id, kicker_id, sender_player_id, content_preview, is_read, created_at)
SELECT DISTINCT
    p.user_id,
    'comment',
    mc.id,
    mc.match_id,
    mc.kicker_id,
    mc.player_id,
    LEFT(mc.content, 100) || CASE WHEN LENGTH(mc.content) > 100 THEN '...' ELSE '' END,
    TRUE,
    mc.created_at
FROM kopecht.match_comments mc
JOIN kopecht.player p ON p.kicker_id = mc.kicker_id AND p.id != mc.player_id AND p.user_id IS NOT NULL
WHERE mc.content LIKE '%@everyone%'
ON CONFLICT DO NOTHING;

-- 15. Migrate historical mentions from chat_messages
INSERT INTO kopecht.mention_notifications (user_id, type, source_id, match_id, kicker_id, sender_player_id, content_preview, is_read, created_at)
SELECT DISTINCT
    p_mentioned.user_id,
    'chat',
    cm.id,
    NULL::BIGINT,
    cm.kicker_id,
    cm.player_id,
    LEFT(cm.content, 100) || CASE WHEN LENGTH(cm.content) > 100 THEN '...' ELSE '' END,
    TRUE,
    cm.created_at
FROM kopecht.chat_messages cm
CROSS JOIN LATERAL (
    SELECT (regexp_matches(cm.content, '@\[[^\]]+\]\((\d+)\)', 'g'))[1]::BIGINT AS mentioned_player_id
) mentions
JOIN kopecht.player p_mentioned ON p_mentioned.id = mentions.mentioned_player_id
WHERE p_mentioned.user_id IS NOT NULL
  AND p_mentioned.id != cm.player_id
ON CONFLICT DO NOTHING;

-- 16. Migrate historical @everyone mentions from chat_messages
INSERT INTO kopecht.mention_notifications (user_id, type, source_id, match_id, kicker_id, sender_player_id, content_preview, is_read, created_at)
SELECT DISTINCT
    p.user_id,
    'chat',
    cm.id,
    NULL::BIGINT,
    cm.kicker_id,
    cm.player_id,
    LEFT(cm.content, 100) || CASE WHEN LENGTH(cm.content) > 100 THEN '...' ELSE '' END,
    TRUE,
    cm.created_at
FROM kopecht.chat_messages cm
JOIN kopecht.player p ON p.kicker_id = cm.kicker_id AND p.id != cm.player_id AND p.user_id IS NOT NULL
WHERE cm.content LIKE '%@everyone%'
ON CONFLICT DO NOTHING;


-- Enable realtime for the table (run this if realtime doesn't work)
ALTER TABLE kopecht.mention_notifications REPLICA IDENTITY FULL;

-- Add to realtime publication
ALTER PUBLICATION supabase_realtime ADD TABLE kopecht.mention_notifications;