-- Set schema explicitly
SET search_path TO public;

-- 1. Create seasons table
CREATE TABLE IF NOT EXISTS seasons (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    kicker_id BIGINT NOT NULL REFERENCES kicker(id) ON DELETE CASCADE,
    season_number INT NOT NULL,
    name TEXT,
    start_date TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    end_date TIMESTAMPTZ,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    UNIQUE(kicker_id, season_number)
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_seasons_kicker_id ON seasons(kicker_id);
CREATE INDEX IF NOT EXISTS idx_seasons_is_active ON seasons(is_active);

-- 2. Add current_season_id to kicker table
ALTER TABLE kicker 
    ADD COLUMN IF NOT EXISTS current_season_id BIGINT REFERENCES seasons(id);

-- 3. Create season_rankings table
CREATE TABLE IF NOT EXISTS season_rankings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    player_id BIGINT NOT NULL REFERENCES player(id) ON DELETE CASCADE,
    season_id BIGINT NOT NULL REFERENCES seasons(id) ON DELETE CASCADE,
    wins BIGINT NOT NULL DEFAULT 0,
    losses BIGINT NOT NULL DEFAULT 0,
    mmr BIGINT NOT NULL DEFAULT 1000,
    wins2on2 BIGINT NOT NULL DEFAULT 0,
    losses2on2 BIGINT NOT NULL DEFAULT 0,
    mmr2on2 BIGINT NOT NULL DEFAULT 1000,
    UNIQUE(player_id, season_id)
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_season_rankings_player_id ON season_rankings(player_id);
CREATE INDEX IF NOT EXISTS idx_season_rankings_season_id ON season_rankings(season_id);

-- 4. Create Season 0 for each existing kicker and migrate data
DO $$
DECLARE
    k RECORD;
    new_season_id BIGINT;
BEGIN
    FOR k IN SELECT id FROM kicker LOOP
        INSERT INTO seasons (kicker_id, season_number, name, is_active, start_date)
        VALUES (k.id, 0, 'Season 0', TRUE, NOW())
        RETURNING id INTO new_season_id;

        UPDATE kicker 
            SET current_season_id = new_season_id 
            WHERE id = k.id;

        UPDATE matches 
            SET season_id = new_season_id 
            WHERE kicker_id = k.id AND season_id IS NULL;

        INSERT INTO season_rankings (player_id, season_id, wins, losses, mmr, wins2on2, losses2on2, mmr2on2)
        SELECT id, new_season_id, wins, losses, mmr, wins2on2, losses2on2, mmr2on2
        FROM player 
        WHERE kicker_id = k.id;
    END LOOP;
END;
$$;

-- 5. Function to get next season number
CREATE OR REPLACE FUNCTION get_next_season_number(p_kicker_id BIGINT)
RETURNS INT AS $$
DECLARE
    next_num INT;
BEGIN
    SELECT COALESCE(MAX(season_number), -1) + 1 INTO next_num
    FROM seasons
    WHERE kicker_id = p_kicker_id;

    RETURN next_num;
END;
$$ LANGUAGE plpgsql;

-- 6. Update get_player_matches_count
CREATE OR REPLACE FUNCTION get_player_matches_count(kicker_id BIGINT, p_season_id BIGINT DEFAULT NULL)
RETURNS TABLE(id BIGINT, name TEXT, match_count BIGINT) AS $$
BEGIN
    RETURN QUERY
    SELECT p.id, p.name, COALESCE(SUM(subquery.cnt)::bigint, 0)
    FROM player p
    LEFT JOIN (
        SELECT m.player1 AS id, COUNT(*) AS cnt
        FROM matches m
        WHERE m.kicker_id = $1 
          AND m.status != 'active'
          AND (p_season_id IS NULL OR m.season_id = p_season_id)
        GROUP BY m.player1
        UNION ALL
        SELECT m.player2 AS id, COUNT(*) AS cnt
        FROM matches m
        WHERE m.kicker_id = $1 
          AND m.status != 'active'
          AND (p_season_id IS NULL OR m.season_id = p_season_id)
        GROUP BY m.player2
        UNION ALL
        SELECT m.player3 AS id, COUNT(*) AS cnt
        FROM matches m
        WHERE m.player3 IS NOT NULL
          AND m.kicker_id = $1 
          AND m.status != 'active'
          AND (p_season_id IS NULL OR m.season_id = p_season_id)
        GROUP BY m.player3
        UNION ALL
        SELECT m.player4 AS id, COUNT(*) AS cnt
        FROM matches m
        WHERE m.player4 IS NOT NULL
          AND m.kicker_id = $1 
          AND m.status != 'active'
          AND (p_season_id IS NULL OR m.season_id = p_season_id)
        GROUP BY m.player4
    ) subquery ON p.id = subquery.id
    WHERE p.kicker_id = $1
    GROUP BY p.id, p.name
    ORDER BY match_count DESC;
END;
$$ LANGUAGE plpgsql;

-- 7. Trigger: create season ranking for new players
CREATE OR REPLACE FUNCTION create_season_ranking_for_new_player()
RETURNS TRIGGER AS $$
DECLARE
    current_season BIGINT;
BEGIN
    SELECT current_season_id INTO current_season
    FROM kicker
    WHERE id = NEW.kicker_id;

    IF current_season IS NOT NULL THEN
        INSERT INTO season_rankings (player_id, season_id, wins, losses, mmr, wins2on2, losses2on2, mmr2on2)
        VALUES (NEW.id, current_season, 0, 0, 1000, 0, 0, 1000)
        ON CONFLICT (player_id, season_id) DO NOTHING;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS after_player_insert_create_season_ranking ON player;

CREATE TRIGGER after_player_insert_create_season_ranking
    AFTER INSERT ON player
    FOR EACH ROW
    EXECUTE FUNCTION create_season_ranking_for_new_player();

-- 8. get_season_rankings function
CREATE OR REPLACE FUNCTION get_season_rankings(p_kicker_id BIGINT, p_season_id BIGINT)
RETURNS TABLE(
    id BIGINT,
    player_id BIGINT,
    name TEXT,
    avatar TEXT,
    wins BIGINT,
    losses BIGINT,
    mmr BIGINT,
    wins2on2 BIGINT,
    losses2on2 BIGINT,
    mmr2on2 BIGINT,
    user_id UUID,
    kicker_id BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        sr.id,
        p.id,
        p.name,
        p.avatar,
        sr.wins,
        sr.losses,
        sr.mmr,
        sr.wins2on2,
        sr.losses2on2,
        sr.mmr2on2,
        p.user_id,
        p.kicker_id
    FROM season_rankings sr
    JOIN player p ON sr.player_id = p.id
    WHERE p.kicker_id = p_kicker_id
      AND sr.season_id = p_season_id;
END;
$$ LANGUAGE plpgsql;

-- 9. RLS
ALTER TABLE seasons ENABLE ROW LEVEL SECURITY;
ALTER TABLE season_rankings ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view seasons for their kickers" ON seasons
    FOR SELECT USING (true);

CREATE POLICY "Users can view season_rankings" ON season_rankings
    FOR SELECT USING (true);

CREATE POLICY "Admins can insert seasons" ON seasons
    FOR INSERT WITH CHECK (true);

CREATE POLICY "Admins can update seasons" ON seasons
    FOR UPDATE USING (true);

CREATE POLICY "System can manage season_rankings" ON season_rankings
    FOR ALL USING (true);
