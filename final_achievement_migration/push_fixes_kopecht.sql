-- Migration: Create combined unread count functions for chat + comments
-- Used for global notification badges (browser tab, PWA badge, iOS badge)

SET search_path TO kopecht;

-- 1. Create function to get combined unread count (chat + comments) for current user
-- This is used by the frontend for browser tab title and PWA badge
-- A comment is considered read if EITHER:
--   - The kicker-wide comment_read_status.last_read_at >= comment.created_at, OR
--   - The match-specific match_comment_read_status.last_read_at >= comment.created_at
CREATE OR REPLACE FUNCTION kopecht.get_combined_unread_count()
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    chat_count BIGINT;
    comment_count BIGINT;
BEGIN
    -- Get chat unread count
    SELECT COALESCE(SUM(unread_count), 0) INTO chat_count
    FROM kopecht.get_unread_count_per_kicker();
    
    -- Get comment unread count (considering both kicker-wide and match-specific read status)
    SELECT COALESCE(COUNT(*), 0) INTO comment_count
    FROM kopecht.match_comments mc
    INNER JOIN kopecht.player p ON p.kicker_id = mc.kicker_id AND p.user_id = auth.uid()
    LEFT JOIN kopecht.comment_read_status crs ON crs.kicker_id = mc.kicker_id AND crs.user_id = auth.uid()
    LEFT JOIN kopecht.match_comment_read_status mcrs ON mcrs.match_id = mc.match_id AND mcrs.user_id = auth.uid()
    WHERE mc.player_id != p.id  -- Don't count own comments
        AND mc.created_at > COALESCE(crs.last_read_at, '1970-01-01'::TIMESTAMPTZ)  -- Not read via kicker-wide
        AND mc.created_at > COALESCE(mcrs.last_read_at, '1970-01-01'::TIMESTAMPTZ); -- Not read via match-specific
    
    RETURN chat_count + comment_count;
END;
$$;

-- 2. Create function to get combined unread count for a specific user (used by edge function for iOS/Android badge)
-- This bypasses RLS and is only accessible by service_role
CREATE OR REPLACE FUNCTION kopecht.get_combined_unread_count_for_user(p_user_id UUID)
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    chat_count BIGINT;
    comment_count BIGINT;
BEGIN
    -- Get chat unread count for user
    SELECT COALESCE(SUM(cnt), 0) INTO chat_count
    FROM (
        SELECT COUNT(cm.id) as cnt
        FROM kopecht.player p
        LEFT JOIN kopecht.chat_read_status crs ON crs.kicker_id = p.kicker_id AND crs.user_id = p_user_id
        LEFT JOIN kopecht.chat_messages cm ON cm.kicker_id = p.kicker_id
            AND cm.created_at > COALESCE(crs.last_read_at, '1970-01-01'::TIMESTAMPTZ)
            AND cm.player_id != p.id
            AND (
                cm.recipient_id IS NULL
                OR
                cm.recipient_id = p.id
            )
        WHERE p.user_id = p_user_id
        GROUP BY p.kicker_id
    ) sub;
    
    -- Get comment unread count for user (considering both kicker-wide and match-specific read status)
    SELECT COALESCE(COUNT(*), 0) INTO comment_count
    FROM kopecht.match_comments mc
    INNER JOIN kopecht.player p ON p.kicker_id = mc.kicker_id AND p.user_id = p_user_id
    LEFT JOIN kopecht.comment_read_status crs ON crs.kicker_id = mc.kicker_id AND crs.user_id = p_user_id
    LEFT JOIN kopecht.match_comment_read_status mcrs ON mcrs.match_id = mc.match_id AND mcrs.user_id = p_user_id
    WHERE mc.player_id != p.id  -- Don't count own comments
        AND mc.created_at > COALESCE(crs.last_read_at, '1970-01-01'::TIMESTAMPTZ)  -- Not read via kicker-wide
        AND mc.created_at > COALESCE(mcrs.last_read_at, '1970-01-01'::TIMESTAMPTZ); -- Not read via match-specific
    
    RETURN chat_count + comment_count;
END;
$$;

-- 3. Grant execute permissions on functions
GRANT EXECUTE ON FUNCTION kopecht.get_combined_unread_count() TO authenticated;
GRANT EXECUTE ON FUNCTION kopecht.get_combined_unread_count_for_user(UUID) TO service_role;



-- Migration: Add match-specific comment read status tracking
-- Used for tracking which comments in a specific match have been read

SET search_path TO kopecht;

-- 1. Create match_comment_read_status table
-- Tracks when a user last read comments for a specific match
CREATE TABLE IF NOT EXISTS kopecht.match_comment_read_status (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    match_id BIGINT NOT NULL REFERENCES kopecht.matches(id) ON DELETE CASCADE,
    last_read_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(user_id, match_id)
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_match_comment_read_status_user_id ON kopecht.match_comment_read_status(user_id);
CREATE INDEX IF NOT EXISTS idx_match_comment_read_status_match_id ON kopecht.match_comment_read_status(match_id);

-- 2. Enable Row Level Security
ALTER TABLE kopecht.match_comment_read_status ENABLE ROW LEVEL SECURITY;

-- 3. RLS Policies

-- Users can view their own read status
CREATE POLICY "Users can view own match comment read status"
ON kopecht.match_comment_read_status FOR SELECT
USING (auth.uid() = user_id);

-- Users can insert their own read status
CREATE POLICY "Users can insert own match comment read status"
ON kopecht.match_comment_read_status FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- Users can update their own read status
CREATE POLICY "Users can update own match comment read status"
ON kopecht.match_comment_read_status FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Users can delete their own read status
CREATE POLICY "Users can delete own match comment read status"
ON kopecht.match_comment_read_status FOR DELETE
USING (auth.uid() = user_id);

-- 4. Create function to update last_read_at for a specific match
CREATE OR REPLACE FUNCTION kopecht.update_match_comment_read_status(p_match_id BIGINT)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    INSERT INTO kopecht.match_comment_read_status (user_id, match_id, last_read_at, updated_at)
    VALUES (auth.uid(), p_match_id, NOW(), NOW())
    ON CONFLICT (user_id, match_id)
    DO UPDATE SET 
        last_read_at = NOW(),
        updated_at = NOW();
END;
$$;

-- 5. Create function to get unread comment count for a specific match
CREATE OR REPLACE FUNCTION kopecht.get_unread_match_comment_count(p_match_id BIGINT)
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_player_id BIGINT;
    v_kicker_id BIGINT;
    v_last_read_at TIMESTAMPTZ;
    v_count BIGINT;
BEGIN
    -- Get kicker_id from the match
    SELECT kicker_id INTO v_kicker_id
    FROM kopecht.matches
    WHERE id = p_match_id;
    
    IF v_kicker_id IS NULL THEN
        RETURN 0;
    END IF;
    
    -- Get the player ID for this user in this kicker
    SELECT id INTO v_player_id
    FROM kopecht.player
    WHERE user_id = auth.uid() AND kicker_id = v_kicker_id;
    
    IF v_player_id IS NULL THEN
        RETURN 0;
    END IF;
    
    -- Get last read timestamp for this specific match
    SELECT last_read_at INTO v_last_read_at
    FROM kopecht.match_comment_read_status
    WHERE user_id = auth.uid() AND match_id = p_match_id;
    
    -- Count unread comments for this match only
    SELECT COUNT(*)::BIGINT INTO v_count
    FROM kopecht.match_comments mc
    WHERE mc.match_id = p_match_id
        AND mc.created_at > COALESCE(v_last_read_at, '1970-01-01'::TIMESTAMPTZ)
        AND mc.player_id != v_player_id;  -- Don't count own comments
    
    RETURN COALESCE(v_count, 0);
END;
$$;

-- 6. Grant execute permissions
GRANT EXECUTE ON FUNCTION kopecht.update_match_comment_read_status(BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION kopecht.get_unread_match_comment_count(BIGINT) TO authenticated;



-- Migration: Add mention notifications system (kopecht schema)
-- Tracks @mentions in comments and chat messages for notification bell feature

-- 1. Create mention_notifications table
CREATE TABLE IF NOT EXISTS kopecht.mention_notifications (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    type VARCHAR(20) NOT NULL CHECK (type IN ('comment', 'chat')),
    source_id BIGINT NOT NULL,
    match_id BIGINT REFERENCES kopecht.matches(id) ON DELETE CASCADE,
    kicker_id BIGINT NOT NULL REFERENCES kopecht.kicker(id) ON DELETE CASCADE,
    sender_player_id BIGINT NOT NULL REFERENCES kopecht.player(id) ON DELETE CASCADE,
    content_preview TEXT NOT NULL,
    is_read BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create indexes for efficient querying
CREATE INDEX IF NOT EXISTS idx_mention_notifications_user_id ON kopecht.mention_notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_mention_notifications_user_unread ON kopecht.mention_notifications(user_id, is_read) WHERE is_read = FALSE;
CREATE INDEX IF NOT EXISTS idx_mention_notifications_created_at ON kopecht.mention_notifications(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_mention_notifications_kicker_id ON kopecht.mention_notifications(kicker_id);

-- 2. Enable Row Level Security
ALTER TABLE kopecht.mention_notifications ENABLE ROW LEVEL SECURITY;

-- Enable REPLICA IDENTITY FULL for realtime subscriptions with filters
ALTER TABLE kopecht.mention_notifications REPLICA IDENTITY FULL;

-- 3. RLS Policies

-- Users can view their own notifications
CREATE POLICY "Users can view own mention notifications"
ON kopecht.mention_notifications FOR SELECT
USING (auth.uid() = user_id);

-- Users can update their own notifications (mark as read)
CREATE POLICY "Users can update own mention notifications"
ON kopecht.mention_notifications FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- Users can delete their own notifications
CREATE POLICY "Users can delete own mention notifications"
ON kopecht.mention_notifications FOR DELETE
USING (auth.uid() = user_id);

-- System can insert notifications (via trigger with SECURITY DEFINER)
-- No INSERT policy needed as triggers run with SECURITY DEFINER

-- 4. Function to get paginated notifications with related data
CREATE OR REPLACE FUNCTION kopecht.get_mention_notifications(p_limit INT DEFAULT 50, p_offset INT DEFAULT 0)
RETURNS TABLE (
    id BIGINT,
    type VARCHAR(20),
    source_id BIGINT,
    match_id BIGINT,
    kicker_id BIGINT,
    kicker_name TEXT,
    sender_player_id BIGINT,
    sender_player_name TEXT,
    sender_avatar TEXT,
    content_preview TEXT,
    is_read BOOLEAN,
    created_at TIMESTAMPTZ,
    match_info JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        mn.id,
        mn.type,
        mn.source_id,
        mn.match_id,
        mn.kicker_id,
        k.name AS kicker_name,
        mn.sender_player_id,
        p.name AS sender_player_name,
        p.avatar AS sender_avatar,
        mn.content_preview,
        mn.is_read,
        mn.created_at,
        CASE 
            WHEN mn.match_id IS NOT NULL THEN
                jsonb_build_object(
                    'id', m.id,
                    'player1_name', p1.name,
                    'player2_name', p2.name,
                    'player3_name', p3.name,
                    'player4_name', p4.name,
                    'scoreTeam1', m."scoreTeam1",
                    'scoreTeam2', m."scoreTeam2"
                )
            ELSE NULL
        END AS match_info
    FROM kopecht.mention_notifications mn
    JOIN kopecht.kicker k ON k.id = mn.kicker_id
    JOIN kopecht.player p ON p.id = mn.sender_player_id
    LEFT JOIN kopecht.matches m ON m.id = mn.match_id
    LEFT JOIN kopecht.player p1 ON p1.id = m.player1
    LEFT JOIN kopecht.player p2 ON p2.id = m.player2
    LEFT JOIN kopecht.player p3 ON p3.id = m.player3
    LEFT JOIN kopecht.player p4 ON p4.id = m.player4
    WHERE mn.user_id = auth.uid()
    ORDER BY mn.created_at DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;

-- 5. Function to get unread mention count
CREATE OR REPLACE FUNCTION kopecht.get_unread_mention_count()
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_count BIGINT;
BEGIN
    SELECT COUNT(*)::BIGINT INTO v_count
    FROM kopecht.mention_notifications
    WHERE user_id = auth.uid() AND is_read = FALSE;
    
    RETURN COALESCE(v_count, 0);
END;
$$;

-- 6. Function to mark single notification as read
CREATE OR REPLACE FUNCTION kopecht.mark_mention_as_read(p_notification_id BIGINT)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    UPDATE kopecht.mention_notifications
    SET is_read = TRUE
    WHERE id = p_notification_id AND user_id = auth.uid();
END;
$$;

-- 7. Function to mark all notifications as read
CREATE OR REPLACE FUNCTION kopecht.mark_all_mentions_as_read()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    UPDATE kopecht.mention_notifications
    SET is_read = TRUE
    WHERE user_id = auth.uid() AND is_read = FALSE;
END;
$$;

-- 8. Helper function to parse mentions and create notifications
CREATE OR REPLACE FUNCTION kopecht.create_mention_notifications(
    p_content TEXT,
    p_type VARCHAR(20),
    p_source_id BIGINT,
    p_match_id BIGINT,
    p_kicker_id BIGINT,
    p_sender_player_id BIGINT
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_mentioned_player_id BIGINT;
    v_mentioned_user_id UUID;
    v_content_preview TEXT;
    v_player_record RECORD;
BEGIN
    -- Truncate content for preview (max 100 chars)
    v_content_preview := LEFT(p_content, 100);
    IF LENGTH(p_content) > 100 THEN
        v_content_preview := v_content_preview || '...';
    END IF;
    
    -- Check for @everyone mention
    IF p_content LIKE '%@everyone%' THEN
        -- Insert notification for all players in the kicker (except sender)
        FOR v_player_record IN 
            SELECT pl.id, pl.user_id 
            FROM kopecht.player pl 
            WHERE pl.kicker_id = p_kicker_id 
              AND pl.id != p_sender_player_id
              AND pl.user_id IS NOT NULL
        LOOP
            INSERT INTO kopecht.mention_notifications (
                user_id, type, source_id, match_id, kicker_id, 
                sender_player_id, content_preview, is_read, created_at
            )
            VALUES (
                v_player_record.user_id, p_type, p_source_id, p_match_id, p_kicker_id,
                p_sender_player_id, v_content_preview, FALSE, NOW()
            )
            ON CONFLICT DO NOTHING;
        END LOOP;
    END IF;
    
    -- Parse individual @[name](player_id) mentions using regex
    -- Pattern: @[any text](digits)
    FOR v_mentioned_player_id IN 
        SELECT (regexp_matches(p_content, '@\[[^\]]+\]\((\d+)\)', 'g'))[1]::BIGINT
    LOOP
        -- Skip if mentioning self
        IF v_mentioned_player_id = p_sender_player_id THEN
            CONTINUE;
        END IF;
        
        -- Get user_id from player
        SELECT user_id INTO v_mentioned_user_id
        FROM kopecht.player
        WHERE id = v_mentioned_player_id;
        
        -- Skip if player has no user_id
        IF v_mentioned_user_id IS NULL THEN
            CONTINUE;
        END IF;
        
        -- Insert notification (avoid duplicates with ON CONFLICT DO NOTHING)
        INSERT INTO kopecht.mention_notifications (
            user_id, type, source_id, match_id, kicker_id,
            sender_player_id, content_preview, is_read, created_at
        )
        VALUES (
            v_mentioned_user_id, p_type, p_source_id, p_match_id, p_kicker_id,
            p_sender_player_id, v_content_preview, FALSE, NOW()
        )
        ON CONFLICT DO NOTHING;
    END LOOP;
END;
$$;

-- 9. Trigger function for match_comments
CREATE OR REPLACE FUNCTION kopecht.trigger_create_comment_mention_notifications()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    PERFORM kopecht.create_mention_notifications(
        NEW.content,
        'comment',
        NEW.id,
        NEW.match_id,
        NEW.kicker_id,
        NEW.player_id
    );
    RETURN NEW;
END;
$$;

-- 10. Trigger function for chat_messages
CREATE OR REPLACE FUNCTION kopecht.trigger_create_chat_mention_notifications()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    PERFORM kopecht.create_mention_notifications(
        NEW.content,
        'chat',
        NEW.id,
        NULL,  -- chat messages don't have match_id
        NEW.kicker_id,
        NEW.player_id
    );
    RETURN NEW;
END;
$$;

-- 11. Create triggers on match_comments and chat_messages
DROP TRIGGER IF EXISTS trigger_comment_mentions ON kopecht.match_comments;
CREATE TRIGGER trigger_comment_mentions
    AFTER INSERT ON kopecht.match_comments
    FOR EACH ROW
    EXECUTE FUNCTION kopecht.trigger_create_comment_mention_notifications();

DROP TRIGGER IF EXISTS trigger_chat_mentions ON kopecht.chat_messages;
CREATE TRIGGER trigger_chat_mentions
    AFTER INSERT ON kopecht.chat_messages
    FOR EACH ROW
    EXECUTE FUNCTION kopecht.trigger_create_chat_mention_notifications();

-- 12. Grant execute permissions
GRANT EXECUTE ON FUNCTION kopecht.get_mention_notifications(INT, INT) TO authenticated;
GRANT EXECUTE ON FUNCTION kopecht.get_unread_mention_count() TO authenticated;
GRANT EXECUTE ON FUNCTION kopecht.mark_mention_as_read(BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION kopecht.mark_all_mentions_as_read() TO authenticated;

-- 13. Migrate historical mentions from match_comments
INSERT INTO kopecht.mention_notifications (user_id, type, source_id, match_id, kicker_id, sender_player_id, content_preview, is_read, created_at)
SELECT DISTINCT
    p_mentioned.user_id,
    'comment',
    mc.id,
    mc.match_id,
    mc.kicker_id,
    mc.player_id,
    LEFT(mc.content, 100) || CASE WHEN LENGTH(mc.content) > 100 THEN '...' ELSE '' END,
    TRUE,  -- Mark historical as read
    mc.created_at
FROM kopecht.match_comments mc
CROSS JOIN LATERAL (
    SELECT (regexp_matches(mc.content, '@\[[^\]]+\]\((\d+)\)', 'g'))[1]::BIGINT AS mentioned_player_id
) mentions
JOIN kopecht.player p_mentioned ON p_mentioned.id = mentions.mentioned_player_id
WHERE p_mentioned.user_id IS NOT NULL
  AND p_mentioned.id != mc.player_id
ON CONFLICT DO NOTHING;

-- 14. Migrate historical @everyone mentions from match_comments
INSERT INTO kopecht.mention_notifications (user_id, type, source_id, match_id, kicker_id, sender_player_id, content_preview, is_read, created_at)
SELECT DISTINCT
    p.user_id,
    'comment',
    mc.id,
    mc.match_id,
    mc.kicker_id,
    mc.player_id,
    LEFT(mc.content, 100) || CASE WHEN LENGTH(mc.content) > 100 THEN '...' ELSE '' END,
    TRUE,
    mc.created_at
FROM kopecht.match_comments mc
JOIN kopecht.player p ON p.kicker_id = mc.kicker_id AND p.id != mc.player_id AND p.user_id IS NOT NULL
WHERE mc.content LIKE '%@everyone%'
ON CONFLICT DO NOTHING;

-- 15. Migrate historical mentions from chat_messages
INSERT INTO kopecht.mention_notifications (user_id, type, source_id, match_id, kicker_id, sender_player_id, content_preview, is_read, created_at)
SELECT DISTINCT
    p_mentioned.user_id,
    'chat',
    cm.id,
    NULL::BIGINT,
    cm.kicker_id,
    cm.player_id,
    LEFT(cm.content, 100) || CASE WHEN LENGTH(cm.content) > 100 THEN '...' ELSE '' END,
    TRUE,
    cm.created_at
FROM kopecht.chat_messages cm
CROSS JOIN LATERAL (
    SELECT (regexp_matches(cm.content, '@\[[^\]]+\]\((\d+)\)', 'g'))[1]::BIGINT AS mentioned_player_id
) mentions
JOIN kopecht.player p_mentioned ON p_mentioned.id = mentions.mentioned_player_id
WHERE p_mentioned.user_id IS NOT NULL
  AND p_mentioned.id != cm.player_id
ON CONFLICT DO NOTHING;

-- 16. Migrate historical @everyone mentions from chat_messages
INSERT INTO kopecht.mention_notifications (user_id, type, source_id, match_id, kicker_id, sender_player_id, content_preview, is_read, created_at)
SELECT DISTINCT
    p.user_id,
    'chat',
    cm.id,
    NULL::BIGINT,
    cm.kicker_id,
    cm.player_id,
    LEFT(cm.content, 100) || CASE WHEN LENGTH(cm.content) > 100 THEN '...' ELSE '' END,
    TRUE,
    cm.created_at
FROM kopecht.chat_messages cm
JOIN kopecht.player p ON p.kicker_id = cm.kicker_id AND p.id != cm.player_id AND p.user_id IS NOT NULL
WHERE cm.content LIKE '%@everyone%'
ON CONFLICT DO NOTHING;


-- Enable realtime for the table (run this if realtime doesn't work)
ALTER TABLE kopecht.mention_notifications REPLICA IDENTITY FULL;

-- Add to realtime publication
ALTER PUBLICATION supabase_realtime ADD TABLE kopecht.mention_notifications;

-- Grant permissions for PostgREST access
GRANT SELECT, INSERT, UPDATE, DELETE ON kopecht.match_comment_read_status TO authenticated;
GRANT USAGE ON SEQUENCE kopecht.match_comment_read_status_id_seq TO authenticated;