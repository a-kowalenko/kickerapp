-- Migration: Create teams and team_invitations tables for permanent 2v2 teams (public schema)
-- Teams have their own MMR separate from individual player MMR

SET search_path TO public;

-- 1. Create teams table
CREATE TABLE IF NOT EXISTS teams (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    logo_url TEXT,
    player1_id BIGINT NOT NULL REFERENCES player(id) ON DELETE CASCADE,
    player2_id BIGINT NOT NULL REFERENCES player(id) ON DELETE CASCADE,
    kicker_id BIGINT NOT NULL REFERENCES kicker(id) ON DELETE CASCADE,
    status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'active', 'dissolved'
    mmr INTEGER NOT NULL DEFAULT 1000,
    wins INTEGER NOT NULL DEFAULT 0,
    losses INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    dissolved_at TIMESTAMPTZ,
    
    -- Team name must be unique within a kicker
    CONSTRAINT teams_name_kicker_unique UNIQUE(name, kicker_id),
    -- Players cannot be the same person
    CONSTRAINT teams_different_players CHECK (player1_id != player2_id)
);

-- Create indexes for teams
CREATE INDEX IF NOT EXISTS idx_teams_kicker_id ON teams(kicker_id);
CREATE INDEX IF NOT EXISTS idx_teams_player1_id ON teams(player1_id);
CREATE INDEX IF NOT EXISTS idx_teams_player2_id ON teams(player2_id);
CREATE INDEX IF NOT EXISTS idx_teams_status ON teams(status);
CREATE INDEX IF NOT EXISTS idx_teams_mmr ON teams(mmr DESC);

-- 2. Create team_invitations table
CREATE TABLE IF NOT EXISTS team_invitations (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    team_id BIGINT NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    inviting_player_id BIGINT NOT NULL REFERENCES player(id) ON DELETE CASCADE,
    invited_player_id BIGINT NOT NULL REFERENCES player(id) ON DELETE CASCADE,
    status TEXT NOT NULL DEFAULT 'pending', -- 'pending', 'accepted', 'declined'
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    responded_at TIMESTAMPTZ,
    
    -- Cannot invite yourself
    CONSTRAINT team_invitations_different_players CHECK (inviting_player_id != invited_player_id)
);

-- Create indexes for team_invitations
CREATE INDEX IF NOT EXISTS idx_team_invitations_team_id ON team_invitations(team_id);
CREATE INDEX IF NOT EXISTS idx_team_invitations_invited_player_id ON team_invitations(invited_player_id);
CREATE INDEX IF NOT EXISTS idx_team_invitations_inviting_player_id ON team_invitations(inviting_player_id);
CREATE INDEX IF NOT EXISTS idx_team_invitations_status ON team_invitations(status);

-- 3. Add team columns to matches table
ALTER TABLE matches 
    ADD COLUMN IF NOT EXISTS team1_id BIGINT REFERENCES teams(id),
    ADD COLUMN IF NOT EXISTS team2_id BIGINT REFERENCES teams(id);

-- Create indexes for team match lookups
CREATE INDEX IF NOT EXISTS idx_matches_team1_id ON matches(team1_id);
CREATE INDEX IF NOT EXISTS idx_matches_team2_id ON matches(team2_id);

-- 4. Enable Row Level Security
ALTER TABLE teams ENABLE ROW LEVEL SECURITY;
ALTER TABLE team_invitations ENABLE ROW LEVEL SECURITY;

-- 5. RLS Policies for teams

-- Users can view teams in their kickers
CREATE POLICY "Users can view teams in their kickers"
ON teams FOR SELECT
USING (
    EXISTS (
        SELECT 1 FROM player
        WHERE player.kicker_id = teams.kicker_id
        AND player.user_id = auth.uid()
    )
);

-- Users can create teams if they are player1 (the creator)
CREATE POLICY "Users can create teams"
ON teams FOR INSERT
WITH CHECK (
    EXISTS (
        SELECT 1 FROM player
        WHERE player.id = teams.player1_id
        AND player.user_id = auth.uid()
    )
);

-- Team members can update their team (name, logo)
CREATE POLICY "Team members can update team"
ON teams FOR UPDATE
USING (
    EXISTS (
        SELECT 1 FROM player
        WHERE (player.id = teams.player1_id OR player.id = teams.player2_id)
        AND player.user_id = auth.uid()
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1 FROM player
        WHERE (player.id = teams.player1_id OR player.id = teams.player2_id)
        AND player.user_id = auth.uid()
    )
);

-- No delete policy - teams are dissolved, not deleted

-- 6. RLS Policies for team_invitations

-- Users can view their own invitations (sent or received)
CREATE POLICY "Users can view own invitations"
ON team_invitations FOR SELECT
USING (
    EXISTS (
        SELECT 1 FROM player
        WHERE (player.id = team_invitations.inviting_player_id 
               OR player.id = team_invitations.invited_player_id)
        AND player.user_id = auth.uid()
    )
);

-- Users can create invitations if they are the inviting player
CREATE POLICY "Users can create invitations"
ON team_invitations FOR INSERT
WITH CHECK (
    EXISTS (
        SELECT 1 FROM player
        WHERE player.id = team_invitations.inviting_player_id
        AND player.user_id = auth.uid()
    )
);

-- Invited users can update invitation status (accept/decline)
CREATE POLICY "Invited users can update invitation"
ON team_invitations FOR UPDATE
USING (
    EXISTS (
        SELECT 1 FROM player
        WHERE player.id = team_invitations.invited_player_id
        AND player.user_id = auth.uid()
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1 FROM player
        WHERE player.id = team_invitations.invited_player_id
        AND player.user_id = auth.uid()
    )
);

-- Inviting users can delete pending invitations (cancel)
CREATE POLICY "Inviting users can delete pending invitations"
ON team_invitations FOR DELETE
USING (
    team_invitations.status = 'pending'
    AND EXISTS (
        SELECT 1 FROM player
        WHERE player.id = team_invitations.inviting_player_id
        AND player.user_id = auth.uid()
    )
);

-- 7. Add tables to realtime publication
ALTER PUBLICATION supabase_realtime ADD TABLE teams;
ALTER PUBLICATION supabase_realtime ADD TABLE team_invitations;

-- ============================================
-- STORAGE BUCKET FOR TEAM LOGOS
-- ============================================
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES ('team-logos', 'team-logos', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp'])
ON CONFLICT (id) DO NOTHING;

-- Storage policies for team-logos bucket
CREATE POLICY "Team logos are publicly accessible"
ON storage.objects FOR SELECT
USING (bucket_id = 'team-logos');

CREATE POLICY "Authenticated users can upload team logos"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'team-logos');

CREATE POLICY "Users can update their team logos"
ON storage.objects FOR UPDATE
TO authenticated
USING (bucket_id = 'team-logos');

CREATE POLICY "Users can delete their team logos"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'team-logos');

-- 8. RPC Function: Dissolve team
CREATE OR REPLACE FUNCTION dissolve_team(p_team_id BIGINT)
RETURNS JSON AS $$
DECLARE
    v_team RECORD;
    v_user_player_id BIGINT;
BEGIN
    -- Get team first to know which kicker it belongs to
    SELECT * INTO v_team
    FROM teams
    WHERE id = p_team_id;
    
    IF v_team IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Team not found');
    END IF;
    
    -- Get current user's player ID for the team's kicker
    SELECT id INTO v_user_player_id
    FROM player
    WHERE user_id = auth.uid() AND kicker_id = v_team.kicker_id
    LIMIT 1;
    
    IF v_user_player_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Player not found');
    END IF;
    
    -- Check if user is a team member
    IF v_team.player1_id != v_user_player_id AND v_team.player2_id != v_user_player_id THEN
        RETURN json_build_object('success', false, 'error', 'Not a team member');
    END IF;
    
    -- Check if team is active
    IF v_team.status != 'active' THEN
        RETURN json_build_object('success', false, 'error', 'Team is not active');
    END IF;
    
    -- Dissolve the team
    UPDATE teams
    SET status = 'dissolved', dissolved_at = NOW()
    WHERE id = p_team_id;
    
    RETURN json_build_object('success', true, 'team_name', v_team.name);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 9. RPC Function: Create team with invitation
CREATE OR REPLACE FUNCTION create_team_with_invitation(
    p_name VARCHAR(50),
    p_partner_player_id BIGINT,
    p_kicker_id BIGINT
)
RETURNS JSON AS $$
DECLARE
    v_user_player_id BIGINT;
    v_team_id BIGINT;
    v_invitation_id BIGINT;
BEGIN
    -- Get current user's player ID for this kicker
    SELECT id INTO v_user_player_id
    FROM player
    WHERE user_id = auth.uid() AND kicker_id = p_kicker_id
    LIMIT 1;
    
    IF v_user_player_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Player not found in this kicker');
    END IF;
    
    -- Check partner exists in same kicker
    IF NOT EXISTS (SELECT 1 FROM player WHERE id = p_partner_player_id AND kicker_id = p_kicker_id) THEN
        RETURN json_build_object('success', false, 'error', 'Partner not found in this kicker');
    END IF;
    
    -- Check if team name already exists in this kicker
    IF EXISTS (SELECT 1 FROM teams WHERE name = p_name AND kicker_id = p_kicker_id AND status != 'dissolved') THEN
        RETURN json_build_object('success', false, 'error', 'Team name already exists');
    END IF;
    
    -- Create team with pending status
    INSERT INTO teams (name, player1_id, player2_id, kicker_id, status)
    VALUES (p_name, v_user_player_id, p_partner_player_id, p_kicker_id, 'pending')
    RETURNING id INTO v_team_id;
    
    -- Create invitation
    INSERT INTO team_invitations (team_id, inviting_player_id, invited_player_id)
    VALUES (v_team_id, v_user_player_id, p_partner_player_id)
    RETURNING id INTO v_invitation_id;
    
    RETURN json_build_object(
        'success', true,
        'team_id', v_team_id,
        'invitation_id', v_invitation_id
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 10. RPC Function: Update team MMR after match
CREATE OR REPLACE FUNCTION update_team_mmr(
    p_team_id BIGINT,
    p_mmr_change INTEGER,
    p_won BOOLEAN
)
RETURNS VOID AS $$
BEGIN
    UPDATE teams
    SET 
        mmr = mmr + p_mmr_change,
        wins = CASE WHEN p_won THEN wins + 1 ELSE wins END,
        losses = CASE WHEN NOT p_won THEN losses + 1 ELSE losses END
    WHERE id = p_team_id AND status = 'active';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 11. RPC Function: Get teams by kicker
CREATE OR REPLACE FUNCTION get_teams_by_kicker(p_kicker_id BIGINT)
RETURNS TABLE (
    id BIGINT,
    name VARCHAR(50),
    logo_url TEXT,
    player1_id BIGINT,
    player1_name TEXT,
    player1_avatar TEXT,
    player2_id BIGINT,
    player2_name TEXT,
    player2_avatar TEXT,
    status TEXT,
    mmr INTEGER,
    wins INTEGER,
    losses INTEGER,
    created_at TIMESTAMPTZ,
    dissolved_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        t.id,
        t.name,
        t.logo_url,
        t.player1_id,
        p1.name AS player1_name,
        p1.avatar AS player1_avatar,
        t.player2_id,
        p2.name AS player2_name,
        p2.avatar AS player2_avatar,
        t.status,
        t.mmr,
        t.wins,
        t.losses,
        t.created_at,
        t.dissolved_at
    FROM teams t
    JOIN player p1 ON t.player1_id = p1.id
    JOIN player p2 ON t.player2_id = p2.id
    WHERE t.kicker_id = p_kicker_id
    ORDER BY t.mmr DESC, t.wins DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 12. RPC Function: Get pending team invitations
CREATE OR REPLACE FUNCTION get_pending_team_invitations(p_player_id BIGINT)
RETURNS TABLE (
    invitation_id BIGINT,
    team_id BIGINT,
    team_name VARCHAR(50),
    inviting_player_id BIGINT,
    inviting_player_name TEXT,
    inviting_player_avatar TEXT,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ti.id AS invitation_id,
        t.id AS team_id,
        t.name AS team_name,
        ti.inviting_player_id,
        p.name AS inviting_player_name,
        p.avatar AS inviting_player_avatar,
        ti.created_at
    FROM team_invitations ti
    JOIN teams t ON ti.team_id = t.id
    JOIN player p ON ti.inviting_player_id = p.id
    WHERE ti.invited_player_id = p_player_id
    AND ti.status = 'pending'
    ORDER BY ti.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- ============================================
-- TEAM HISTORY TABLE
-- Tracks team MMR changes over time
-- ============================================

-- 13. Create team_history table
CREATE TABLE IF NOT EXISTS team_history (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    team_id BIGINT NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    match_id BIGINT REFERENCES matches(id) ON DELETE SET NULL,
    mmr_before INTEGER NOT NULL,
    mmr_after INTEGER NOT NULL,
    mmr_change INTEGER NOT NULL,
    wins_before INTEGER NOT NULL DEFAULT 0,
    wins_after INTEGER NOT NULL DEFAULT 0,
    losses_before INTEGER NOT NULL DEFAULT 0,
    losses_after INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 14. Create indexes for team_history
CREATE INDEX IF NOT EXISTS idx_team_history_team_id ON team_history(team_id);
CREATE INDEX IF NOT EXISTS idx_team_history_match_id ON team_history(match_id);
CREATE INDEX IF NOT EXISTS idx_team_history_created_at ON team_history(created_at DESC);

-- 15. Enable RLS on team_history
ALTER TABLE team_history ENABLE ROW LEVEL SECURITY;

-- 16. Create RLS policies
CREATE POLICY "Team history is viewable by everyone"
    ON team_history FOR SELECT
    USING (true);

-- 17. Grant permissions
GRANT SELECT ON team_history TO authenticated;
GRANT SELECT ON team_history TO anon;

-- 18. RPC Function: Get team MMR history
CREATE OR REPLACE FUNCTION get_team_mmr_history(
    p_team_id BIGINT,
    p_limit INTEGER DEFAULT 50
)
RETURNS TABLE (
    id BIGINT,
    match_id BIGINT,
    mmr_before INTEGER,
    mmr_after INTEGER,
    mmr_change INTEGER,
    wins_after INTEGER,
    losses_after INTEGER,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        th.id,
        th.match_id,
        th.mmr_before,
        th.mmr_after,
        th.mmr_change,
        th.wins_after,
        th.losses_after,
        th.created_at
    FROM team_history th
    WHERE th.team_id = p_team_id
    ORDER BY th.created_at DESC
    LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_team_mmr_history(BIGINT, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION get_team_mmr_history(BIGINT, INTEGER) TO anon;


-- 19. RPC Function: Accept team invitation (with correct kicker context)
-- A user can have multiple players across different kickers
-- We need to find the player for the specific kicker the team belongs to
CREATE OR REPLACE FUNCTION accept_team_invitation(p_invitation_id BIGINT)
RETURNS JSON AS $$
DECLARE
    v_invitation RECORD;
    v_team RECORD;
    v_user_player_id BIGINT;
    v_kicker_id BIGINT;
BEGIN
    -- Get invitation first to know which team/kicker we're dealing with
    SELECT * INTO v_invitation
    FROM team_invitations
    WHERE id = p_invitation_id;
    
    IF v_invitation IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Invitation not found');
    END IF;
    
    -- Get the kicker_id from the team
    SELECT kicker_id INTO v_kicker_id
    FROM teams
    WHERE id = v_invitation.team_id;
    
    -- Get current user's player ID for this specific kicker
    SELECT id INTO v_user_player_id
    FROM player
    WHERE user_id = auth.uid()
    AND kicker_id = v_kicker_id
    LIMIT 1;
    
    IF v_user_player_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Player not found for this kicker');
    END IF;
    
    -- Check if user is the invited player
    IF v_invitation.invited_player_id != v_user_player_id THEN
        RETURN json_build_object('success', false, 'error', 'Not authorized');
    END IF;
    
    -- Check if invitation is still pending
    IF v_invitation.status != 'pending' THEN
        RETURN json_build_object('success', false, 'error', 'Invitation already responded to');
    END IF;
    
    -- Update invitation status
    UPDATE team_invitations
    SET status = 'accepted', responded_at = NOW()
    WHERE id = p_invitation_id;
    
    -- Activate the team
    UPDATE teams
    SET status = 'active'
    WHERE id = v_invitation.team_id;
    
    -- Get team info for response
    SELECT * INTO v_team
    FROM teams
    WHERE id = v_invitation.team_id;
    
    RETURN json_build_object(
        'success', true, 
        'team_id', v_team.id,
        'team_name', v_team.name
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 20. RPC Function: Decline team invitation (with correct kicker context)
CREATE OR REPLACE FUNCTION decline_team_invitation(p_invitation_id BIGINT)
RETURNS JSON AS $$
DECLARE
    v_invitation RECORD;
    v_user_player_id BIGINT;
    v_kicker_id BIGINT;
BEGIN
    -- Get invitation first to know which team/kicker we're dealing with
    SELECT * INTO v_invitation
    FROM team_invitations
    WHERE id = p_invitation_id;
    
    IF v_invitation IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Invitation not found');
    END IF;
    
    -- Get the kicker_id from the team
    SELECT kicker_id INTO v_kicker_id
    FROM teams
    WHERE id = v_invitation.team_id;
    
    -- Get current user's player ID for this specific kicker
    SELECT id INTO v_user_player_id
    FROM player
    WHERE user_id = auth.uid()
    AND kicker_id = v_kicker_id
    LIMIT 1;
    
    IF v_user_player_id IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Player not found for this kicker');
    END IF;
    
    -- Check if user is the invited player
    IF v_invitation.invited_player_id != v_user_player_id THEN
        RETURN json_build_object('success', false, 'error', 'Not authorized');
    END IF;
    
    -- Check if invitation is still pending
    IF v_invitation.status != 'pending' THEN
        RETURN json_build_object('success', false, 'error', 'Invitation already responded to');
    END IF;
    
    -- Update invitation status
    UPDATE team_invitations
    SET status = 'declined', responded_at = NOW()
    WHERE id = p_invitation_id;
    
    -- Delete the pending team
    DELETE FROM teams
    WHERE id = v_invitation.team_id;
    
    RETURN json_build_object('success', true);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- 21. Function: Record team history after match
-- Uses correct camelCase column names from matches table
CREATE OR REPLACE FUNCTION record_team_history()
RETURNS TRIGGER AS $$
BEGIN
    -- Only process if this is a team match (has team1_id and team2_id)
    IF NEW.team1_id IS NOT NULL AND NEW.team2_id IS NOT NULL THEN
        -- Record history for team 1
        INSERT INTO team_history (
            team_id,
            match_id,
            mmr_before,
            mmr_after,
            mmr_change,
            wins_before,
            wins_after,
            losses_before,
            losses_after
        )
        SELECT 
            NEW.team1_id,
            NEW.id,
            t.mmr - COALESCE(NEW."mmrChangeTeam1", 0),
            t.mmr,
            COALESCE(NEW."mmrChangeTeam1", 0),
            CASE WHEN NEW."scoreTeam1" > NEW."scoreTeam2" THEN t.wins - 1 ELSE t.wins END,
            t.wins,
            CASE WHEN NEW."scoreTeam1" < NEW."scoreTeam2" THEN t.losses - 1 ELSE t.losses END,
            t.losses
        FROM teams t
        WHERE t.id = NEW.team1_id;

        -- Record history for team 2
        INSERT INTO team_history (
            team_id,
            match_id,
            mmr_before,
            mmr_after,
            mmr_change,
            wins_before,
            wins_after,
            losses_before,
            losses_after
        )
        SELECT 
            NEW.team2_id,
            NEW.id,
            t.mmr - COALESCE(NEW."mmrChangeTeam2", 0),
            t.mmr,
            COALESCE(NEW."mmrChangeTeam2", 0),
            CASE WHEN NEW."scoreTeam2" > NEW."scoreTeam1" THEN t.wins - 1 ELSE t.wins END,
            t.wins,
            CASE WHEN NEW."scoreTeam2" < NEW."scoreTeam1" THEN t.losses - 1 ELSE t.losses END,
            t.losses
        FROM teams t
        WHERE t.id = NEW.team2_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 22. Trigger for team history on match completion
DROP TRIGGER IF EXISTS trigger_record_team_history ON matches;
CREATE TRIGGER trigger_record_team_history
    AFTER UPDATE OF end_time ON matches
    FOR EACH ROW
    WHEN (OLD.end_time IS NULL AND NEW.end_time IS NOT NULL)
    EXECUTE FUNCTION record_team_history();


-- ============================================
-- RLS POLICIES FOR MATCHES TABLE
-- ============================================
-- These policies allow users to interact with matches if they have a player in the same kicker

SET search_path TO public;

-- Ensure RLS is enabled
ALTER TABLE matches ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if any (to avoid conflicts)
DROP POLICY IF EXISTS "access_control_on_matches" ON matches;
DROP POLICY IF EXISTS "insert_control_on_matches" ON matches;
DROP POLICY IF EXISTS "update_control_on_matches" ON matches;
DROP POLICY IF EXISTS "delete_control_on_matches" ON matches;

-- SELECT Policy - Allow users to read matches from their kicker
CREATE POLICY "access_control_on_matches"
ON matches
AS PERMISSIVE
FOR SELECT
TO public
USING (
    EXISTS (
        SELECT 1
        FROM player
        WHERE player.kicker_id = matches.kicker_id 
          AND player.user_id = auth.uid()
    )
);

-- INSERT Policy - Allow users to create matches in their kicker
CREATE POLICY "insert_control_on_matches"
ON matches
AS PERMISSIVE
FOR INSERT
TO public
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM player
        WHERE player.kicker_id = matches.kicker_id 
          AND player.user_id = auth.uid()
    )
);

-- UPDATE Policy - Allow users to update matches in their kicker
CREATE POLICY "update_control_on_matches"
ON matches
AS PERMISSIVE
FOR UPDATE
TO public
USING (
    EXISTS (
        SELECT 1
        FROM player
        WHERE player.kicker_id = matches.kicker_id 
          AND player.user_id = auth.uid()
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM player
        WHERE player.kicker_id = matches.kicker_id 
          AND player.user_id = auth.uid()
    )
);

-- DELETE Policy - Allow users to delete matches in their kicker
CREATE POLICY "delete_control_on_matches"
ON matches
AS PERMISSIVE
FOR DELETE
TO public
USING (
    EXISTS (
        SELECT 1
        FROM player
        WHERE player.kicker_id = matches.kicker_id 
          AND player.user_id = auth.uid()
    )
);

-- Grant table-level permissions to authenticated users
GRANT SELECT, INSERT, UPDATE, DELETE ON matches TO authenticated;
GRANT USAGE ON SEQUENCE matches_id_seq TO authenticated;


-- ============================================
-- GRANTS FOR MATCH_COMMENT_READ_STATUS TABLE
-- ============================================

-- Grant table-level permissions to authenticated users
GRANT SELECT, INSERT, UPDATE, DELETE ON match_comment_read_status TO authenticated;
GRANT USAGE ON SEQUENCE match_comment_read_status_id_seq TO authenticated;


-- ============================================
-- ADDITIONAL RLS POLICIES FOR TEAM_HISTORY TABLE
-- These policies allow users to interact with team_history if they have a player in the same kicker
-- ============================================

-- Drop existing policies if any (to avoid conflicts)
DROP POLICY IF EXISTS "Team history is viewable by everyone" ON team_history;
DROP POLICY IF EXISTS "access_control_on_team_history" ON team_history;
DROP POLICY IF EXISTS "insert_control_on_team_history" ON team_history;
DROP POLICY IF EXISTS "update_control_on_team_history" ON team_history;
DROP POLICY IF EXISTS "delete_control_on_team_history" ON team_history;

-- SELECT Policy - Allow users to read team_history from their kicker
CREATE POLICY "access_control_on_team_history"
ON team_history
AS PERMISSIVE
FOR SELECT
TO public
USING (
    EXISTS (
        SELECT 1
        FROM teams t
        JOIN player p ON p.kicker_id = t.kicker_id
        WHERE t.id = team_history.team_id 
          AND p.user_id = auth.uid()
    )
);

-- INSERT Policy - Allow users to create team_history in their kicker
CREATE POLICY "insert_control_on_team_history"
ON team_history
AS PERMISSIVE
FOR INSERT
TO public
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM teams t
        JOIN player p ON p.kicker_id = t.kicker_id
        WHERE t.id = team_history.team_id 
          AND p.user_id = auth.uid()
    )
);

-- UPDATE Policy - Allow users to update team_history in their kicker
CREATE POLICY "update_control_on_team_history"
ON team_history
AS PERMISSIVE
FOR UPDATE
TO public
USING (
    EXISTS (
        SELECT 1
        FROM teams t
        JOIN player p ON p.kicker_id = t.kicker_id
        WHERE t.id = team_history.team_id 
          AND p.user_id = auth.uid()
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM teams t
        JOIN player p ON p.kicker_id = t.kicker_id
        WHERE t.id = team_history.team_id 
          AND p.user_id = auth.uid()
    )
);

-- DELETE Policy - Allow users to delete team_history in their kicker
CREATE POLICY "delete_control_on_team_history"
ON team_history
AS PERMISSIVE
FOR DELETE
TO public
USING (
    EXISTS (
        SELECT 1
        FROM teams t
        JOIN player p ON p.kicker_id = t.kicker_id
        WHERE t.id = team_history.team_id 
          AND p.user_id = auth.uid()
    )
);

-- Grant table-level permissions to authenticated users
GRANT SELECT, INSERT, UPDATE, DELETE ON team_history TO authenticated;
GRANT USAGE ON SEQUENCE team_history_id_seq TO authenticated;


-- ============================================
-- TEAM SEASON RANKINGS TABLE
-- Tracks team MMR and stats per season
-- ============================================

-- 23. Create team_season_rankings table
CREATE TABLE IF NOT EXISTS team_season_rankings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    team_id BIGINT NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    season_id BIGINT NOT NULL REFERENCES seasons(id) ON DELETE CASCADE,
    wins BIGINT NOT NULL DEFAULT 0,
    losses BIGINT NOT NULL DEFAULT 0,
    mmr BIGINT NOT NULL DEFAULT 1000,
    bounty_claimed INTEGER NULL DEFAULT 0,
    
    -- Each team can only have one ranking per season
    CONSTRAINT team_season_rankings_team_id_season_id_key UNIQUE (team_id, season_id)
);

-- Indexes for team_season_rankings
CREATE INDEX IF NOT EXISTS team_season_rankings_team_id_idx ON team_season_rankings(team_id);
CREATE INDEX IF NOT EXISTS team_season_rankings_season_id_idx ON team_season_rankings(season_id);

-- Enable RLS
ALTER TABLE team_season_rankings ENABLE ROW LEVEL SECURITY;

-- RLS Policies for team_season_rankings
-- SELECT Policy - Users can view team rankings from their kicker
CREATE POLICY "access_control_on_team_season_rankings"
ON team_season_rankings
AS PERMISSIVE
FOR SELECT
TO public
USING (
    EXISTS (
        SELECT 1
        FROM teams t
        JOIN player p ON p.kicker_id = t.kicker_id
        WHERE t.id = team_season_rankings.team_id 
          AND p.user_id = auth.uid()
    )
);

-- INSERT Policy
CREATE POLICY "insert_control_on_team_season_rankings"
ON team_season_rankings
AS PERMISSIVE
FOR INSERT
TO public
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM teams t
        JOIN player p ON p.kicker_id = t.kicker_id
        WHERE t.id = team_season_rankings.team_id 
          AND p.user_id = auth.uid()
    )
);

-- UPDATE Policy
CREATE POLICY "update_control_on_team_season_rankings"
ON team_season_rankings
AS PERMISSIVE
FOR UPDATE
TO public
USING (
    EXISTS (
        SELECT 1
        FROM teams t
        JOIN player p ON p.kicker_id = t.kicker_id
        WHERE t.id = team_season_rankings.team_id 
          AND p.user_id = auth.uid()
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM teams t
        JOIN player p ON p.kicker_id = t.kicker_id
        WHERE t.id = team_season_rankings.team_id 
          AND p.user_id = auth.uid()
    )
);

-- DELETE Policy
CREATE POLICY "delete_control_on_team_season_rankings"
ON team_season_rankings
AS PERMISSIVE
FOR DELETE
TO public
USING (
    EXISTS (
        SELECT 1
        FROM teams t
        JOIN player p ON p.kicker_id = t.kicker_id
        WHERE t.id = team_season_rankings.team_id 
          AND p.user_id = auth.uid()
    )
);

-- 24. Grant permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON team_season_rankings TO authenticated;
GRANT USAGE ON SEQUENCE team_season_rankings_id_seq TO authenticated;

-- 25. Function: Get or create team season ranking
CREATE OR REPLACE FUNCTION get_or_create_team_season_ranking(
    p_team_id BIGINT,
    p_season_id BIGINT
)
RETURNS team_season_rankings
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_ranking team_season_rankings;
BEGIN
    -- Try to get existing ranking
    SELECT * INTO v_ranking
    FROM team_season_rankings
    WHERE team_id = p_team_id AND season_id = p_season_id;
    
    -- If not found, create it
    IF v_ranking IS NULL THEN
        INSERT INTO team_season_rankings (team_id, season_id, wins, losses, mmr)
        VALUES (p_team_id, p_season_id, 0, 0, 1000)
        RETURNING * INTO v_ranking;
    END IF;
    
    RETURN v_ranking;
END;
$$;

-- 26. Function: Update team season ranking after match
CREATE OR REPLACE FUNCTION update_team_season_ranking(
    p_team_id BIGINT,
    p_season_id BIGINT,
    p_mmr_change INTEGER,
    p_won BOOLEAN
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Ensure ranking exists
    PERFORM get_or_create_team_season_ranking(p_team_id, p_season_id);
    
    -- Update the ranking
    UPDATE team_season_rankings
    SET 
        mmr = mmr + p_mmr_change,
        wins = CASE WHEN p_won THEN wins + 1 ELSE wins END,
        losses = CASE WHEN NOT p_won THEN losses + 1 ELSE losses END
    WHERE team_id = p_team_id AND season_id = p_season_id;
END;
$$;

-- 27. Function: Get team season rankings for leaderboard
CREATE OR REPLACE FUNCTION get_team_season_rankings(
    p_kicker_id BIGINT,
    p_season_id BIGINT
)
RETURNS TABLE (
    team_id BIGINT,
    team_name VARCHAR(50),
    logo_url TEXT,
    player1_id BIGINT,
    player1_name TEXT,
    player1_avatar TEXT,
    player2_id BIGINT,
    player2_name TEXT,
    player2_avatar TEXT,
    wins BIGINT,
    losses BIGINT,
    mmr BIGINT,
    total_matches BIGINT,
    win_rate NUMERIC
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        t.id AS team_id,
        t.name AS team_name,
        t.logo_url,
        p1.id AS player1_id,
        p1.name::TEXT AS player1_name,
        p1.avatar AS player1_avatar,
        p2.id AS player2_id,
        p2.name::TEXT AS player2_name,
        p2.avatar AS player2_avatar,
        COALESCE(tsr.wins, 0::BIGINT) AS wins,
        COALESCE(tsr.losses, 0::BIGINT) AS losses,
        COALESCE(tsr.mmr, 1000::BIGINT) AS mmr,
        COALESCE(tsr.wins, 0) + COALESCE(tsr.losses, 0) AS total_matches,
        CASE 
            WHEN COALESCE(tsr.wins, 0) + COALESCE(tsr.losses, 0) = 0 THEN 0
            ELSE ROUND(COALESCE(tsr.wins, 0)::NUMERIC / (COALESCE(tsr.wins, 0) + COALESCE(tsr.losses, 0)) * 100, 1)
        END AS win_rate
    FROM teams t
    JOIN player p1 ON t.player1_id = p1.id
    JOIN player p2 ON t.player2_id = p2.id
    LEFT JOIN team_season_rankings tsr ON t.id = tsr.team_id AND tsr.season_id = p_season_id
    WHERE t.kicker_id = p_kicker_id
      AND t.status = 'active'
    ORDER BY COALESCE(tsr.mmr, 1000) DESC, COALESCE(tsr.wins, 0) DESC;
END;
$$;

-- 28. Grant execute permissions
GRANT EXECUTE ON FUNCTION get_or_create_team_season_ranking(BIGINT, BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION update_team_season_ranking(BIGINT, BIGINT, INTEGER, BOOLEAN) TO authenticated;
GRANT EXECUTE ON FUNCTION get_team_season_rankings(BIGINT, BIGINT) TO authenticated;


-- ============================================
-- TEAM STATUS SYSTEM WITH BOUNTIES
-- Similar to player_status but for permanent teams
-- ============================================

-- 29. Create team_status table
CREATE TABLE IF NOT EXISTS team_status (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    team_id BIGINT NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    -- Current streak (positive = wins, negative = losses)
    current_streak INT NOT NULL DEFAULT 0,
    -- Accumulated bounty from streak (in MMR)
    current_bounty INT NOT NULL DEFAULT 0,
    -- Active status effects (keys from status_definitions)
    active_statuses TEXT[] DEFAULT '{}',
    -- Last match that affected this status
    last_match_id BIGINT,
    -- Timestamps
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    -- One entry per team
    CONSTRAINT team_status_unique UNIQUE (team_id)
);

-- 30. Create team_bounty_history table
CREATE TABLE IF NOT EXISTS team_bounty_history (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- Team who claimed the bounty
    claimer_team_id BIGINT NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    -- Team whose streak was broken
    victim_team_id BIGINT NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    -- Match where the bounty was claimed
    match_id BIGINT NOT NULL,
    -- The streak that was broken
    streak_broken INT NOT NULL,
    -- Bounty amount paid out
    bounty_amount INT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 31. Indexes for team_status and team_bounty_history
CREATE INDEX IF NOT EXISTS idx_team_status_team ON team_status(team_id);
CREATE INDEX IF NOT EXISTS idx_team_status_updated ON team_status(updated_at);
CREATE INDEX IF NOT EXISTS idx_team_bounty_history_claimer ON team_bounty_history(claimer_team_id);
CREATE INDEX IF NOT EXISTS idx_team_bounty_history_victim ON team_bounty_history(victim_team_id);
CREATE INDEX IF NOT EXISTS idx_team_bounty_history_created ON team_bounty_history(created_at);

-- 32. RLS Policies for team_status and team_bounty_history
ALTER TABLE team_status ENABLE ROW LEVEL SECURITY;
ALTER TABLE team_bounty_history ENABLE ROW LEVEL SECURITY;

-- Team status: Users can view team status from their kicker
CREATE POLICY "team_status_select_policy" ON team_status
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM teams t
            JOIN player p ON p.kicker_id = t.kicker_id
            WHERE t.id = team_status.team_id 
              AND p.user_id = auth.uid()
        )
    );

-- Team bounty history: Users can view from their kicker
CREATE POLICY "team_bounty_history_select_policy" ON team_bounty_history
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM teams t
            JOIN player p ON p.kicker_id = t.kicker_id
            WHERE t.id = team_bounty_history.claimer_team_id 
              AND p.user_id = auth.uid()
        )
    );

-- 33. Add bounty columns to matches table for teams
ALTER TABLE matches 
    ADD COLUMN IF NOT EXISTS bounty_team1_team INTEGER DEFAULT 0,
    ADD COLUMN IF NOT EXISTS bounty_team2_team INTEGER DEFAULT 0;

-- 34. Function: Update team status after match
DROP FUNCTION IF EXISTS update_team_status_after_match(BIGINT, BIGINT, BOOLEAN, INT);

CREATE OR REPLACE FUNCTION update_team_status_after_match(
    p_team_id BIGINT,
    p_match_id BIGINT,
    p_is_winner BOOLEAN,
    p_opponent_team_id BIGINT
)
RETURNS TABLE (
    bounty_claimed INT,
    bounty_victim_id BIGINT,
    new_status TEXT[],
    streak INT,
    bounty_gained INT,
    old_streak INT
) AS $$
DECLARE
    v_current_streak INT;
    v_new_streak INT;
    v_current_bounty INT;
    v_new_bounty INT;
    v_threshold_bounty INT;
    v_bounty_gained INT := 0;
    v_active_statuses TEXT[];
    v_bounty_to_claim INT := 0;
    v_bounty_victim BIGINT := NULL;
    v_opponent_status RECORD;
    v_status_def RECORD;
BEGIN
    -- Get or create team status record
    INSERT INTO team_status (team_id, current_streak, current_bounty, active_statuses)
    VALUES (p_team_id, 0, 0, '{}')
    ON CONFLICT (team_id) DO NOTHING;
    
    -- Get current status
    SELECT current_streak, current_bounty, active_statuses
    INTO v_current_streak, v_current_bounty, v_active_statuses
    FROM team_status
    WHERE team_id = p_team_id;
    
    -- Calculate new streak
    IF p_is_winner THEN
        IF v_current_streak >= 0 THEN
            v_new_streak := v_current_streak + 1;
        ELSE
            v_new_streak := 1;  -- Reset from loss streak
        END IF;
    ELSE
        IF v_current_streak <= 0 THEN
            v_new_streak := v_current_streak - 1;
        ELSE
            v_new_streak := -1;  -- Reset from win streak
        END IF;
    END IF;
    
    -- ============================================
    -- BOUNTY CALCULATION
    -- Only add bounty when crossing a threshold (3, 5, 7, 10)
    -- Uses same status_definitions as player bounty
    -- ============================================
    IF p_is_winner AND v_new_streak >= 3 THEN
        -- Keep existing bounty as base (or 0 if coming from loss streak)
        IF v_current_streak >= 0 THEN
            v_new_bounty := v_current_bounty;
        ELSE
            v_new_bounty := 0;
        END IF;
        
        -- Check if we just crossed a threshold (3, 5, 7, or 10)
        SELECT bounty_per_streak INTO v_threshold_bounty
        FROM status_definitions
        WHERE type = 'streak' 
          AND (condition->>'streak_type') = 'win'
          AND (condition->>'min_streak')::int = v_new_streak
          AND v_current_streak < v_new_streak;
        
        -- Add threshold bounty if we crossed one
        IF v_threshold_bounty IS NOT NULL AND v_threshold_bounty > 0 THEN
            v_new_bounty := v_new_bounty + v_threshold_bounty;
            v_bounty_gained := v_threshold_bounty;
        END IF;
    ELSE
        -- Not on a win streak of 3+, bounty is 0
        v_new_bounty := 0;
    END IF;
    
    -- Check if we need to claim bounty from opponent team (if we won and broke their streak)
    IF p_is_winner AND p_opponent_team_id IS NOT NULL THEN
        SELECT ts.team_id, ts.current_streak, ts.current_bounty
        INTO v_opponent_status
        FROM team_status ts
        WHERE ts.team_id = p_opponent_team_id
          AND ts.current_streak >= 3;
        
        IF v_opponent_status IS NOT NULL AND v_opponent_status.current_bounty > 0 THEN
            v_bounty_to_claim := v_opponent_status.current_bounty;
            v_bounty_victim := v_opponent_status.team_id;
            
            -- Record bounty claim in history
            INSERT INTO team_bounty_history (claimer_team_id, victim_team_id, match_id, streak_broken, bounty_amount)
            VALUES (p_team_id, v_opponent_status.team_id, p_match_id, v_opponent_status.current_streak, v_opponent_status.current_bounty);
        END IF;
    END IF;
    
    -- Determine active statuses based on new streak
    v_active_statuses := '{}';
    
    FOR v_status_def IN
        SELECT key, condition
        FROM status_definitions
        WHERE type = 'streak'
        ORDER BY priority DESC
    LOOP
        IF (v_status_def.condition->>'streak_type') = 'win' AND v_new_streak >= (v_status_def.condition->>'min_streak')::int THEN
            v_active_statuses := array_append(v_active_statuses, v_status_def.key);
        ELSIF (v_status_def.condition->>'streak_type') = 'loss' AND v_new_streak <= -(v_status_def.condition->>'min_streak')::int THEN
            v_active_statuses := array_append(v_active_statuses, v_status_def.key);
        END IF;
    END LOOP;
    
    -- Update team status
    UPDATE team_status
    SET current_streak = v_new_streak,
        current_bounty = v_new_bounty,
        active_statuses = v_active_statuses,
        last_match_id = p_match_id,
        updated_at = NOW()
    WHERE team_id = p_team_id;
    
    -- Return results
    bounty_claimed := v_bounty_to_claim;
    bounty_victim_id := v_bounty_victim;
    new_status := v_active_statuses;
    streak := v_new_streak;
    bounty_gained := v_bounty_gained;
    old_streak := v_current_streak;
    
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 35. Function: Get team bounty for match display
DROP FUNCTION IF EXISTS get_team_bounty_for_team(BIGINT);

CREATE OR REPLACE FUNCTION get_team_bounty_for_team(
    p_team_id BIGINT
)
RETURNS INT AS $$
DECLARE
    v_bounty INT;
BEGIN
    SELECT COALESCE(current_bounty, 0)
    INTO v_bounty
    FROM team_status
    WHERE team_id = p_team_id;
    
    RETURN COALESCE(v_bounty, 0);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 36. Function: Get player team stats (aggregated)
DROP FUNCTION IF EXISTS get_player_team_stats(BIGINT, BIGINT);

CREATE OR REPLACE FUNCTION get_player_team_stats(
    p_player_id BIGINT,
    p_season_id BIGINT DEFAULT NULL
)
RETURNS TABLE (
    wins BIGINT,
    losses BIGINT,
    bounty_claimed BIGINT
) AS $$
BEGIN
    IF p_season_id IS NULL THEN
        -- All-time stats from teams table
        RETURN QUERY
        SELECT 
            COALESCE(SUM(t.wins), 0)::BIGINT AS wins,
            COALESCE(SUM(t.losses), 0)::BIGINT AS losses,
            0::BIGINT AS bounty_claimed  -- All-time bounty not tracked separately
        FROM teams t
        WHERE (t.player1_id = p_player_id OR t.player2_id = p_player_id);
    ELSE
        -- Season-specific stats from team_season_rankings
        RETURN QUERY
        SELECT 
            COALESCE(SUM(tsr.wins), 0)::BIGINT AS wins,
            COALESCE(SUM(tsr.losses), 0)::BIGINT AS losses,
            COALESCE(SUM(tsr.bounty_claimed), 0)::BIGINT AS bounty_claimed
        FROM teams t
        JOIN team_season_rankings tsr ON t.id = tsr.team_id AND tsr.season_id = p_season_id
        WHERE (t.player1_id = p_player_id OR t.player2_id = p_player_id);
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 37. Function: Update team season ranking with bounty
DROP FUNCTION IF EXISTS update_team_season_ranking_with_bounty(BIGINT, BIGINT, INTEGER, BOOLEAN, INTEGER);

CREATE OR REPLACE FUNCTION update_team_season_ranking_with_bounty(
    p_team_id BIGINT,
    p_season_id BIGINT,
    p_mmr_change INTEGER,
    p_won BOOLEAN,
    p_bounty_claimed INTEGER DEFAULT 0
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Ensure ranking exists
    PERFORM get_or_create_team_season_ranking(p_team_id, p_season_id);
    
    -- Update the ranking
    -- Add bounty_claimed to MMR for winner (same as player bounty logic)
    UPDATE team_season_rankings
    SET 
        mmr = mmr + p_mmr_change + p_bounty_claimed,
        wins = CASE WHEN p_won THEN wins + 1 ELSE wins END,
        losses = CASE WHEN NOT p_won THEN losses + 1 ELSE losses END,
        bounty_claimed = bounty_claimed + p_bounty_claimed
    WHERE team_id = p_team_id AND season_id = p_season_id;
END;
$$;

-- 38. Final grants for team status functions
GRANT SELECT ON team_status TO authenticated;
GRANT SELECT ON team_bounty_history TO authenticated;
GRANT EXECUTE ON FUNCTION update_team_status_after_match(BIGINT, BIGINT, BOOLEAN, BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION update_team_status_after_match(BIGINT, BIGINT, BOOLEAN, BIGINT) TO service_role;
GRANT EXECUTE ON FUNCTION get_team_bounty_for_team(BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION get_player_team_stats(BIGINT, BIGINT) TO authenticated;
GRANT EXECUTE ON FUNCTION update_team_season_ranking_with_bounty(BIGINT, BIGINT, INTEGER, BOOLEAN, INTEGER) TO authenticated;


-- Migration: Add team invite notifications to mention_notifications system (public schema)
-- Creates notifications when players receive team invitations
-- Auto-marks notification as read when invitation is responded to

SET search_path TO public;

-- 1. Alter mention_notifications table to support team invites
-- Drop old constraint and add new one with 'team_invite' type
ALTER TABLE mention_notifications 
DROP CONSTRAINT IF EXISTS mention_notifications_type_check;

ALTER TABLE mention_notifications 
ADD CONSTRAINT mention_notifications_type_check 
CHECK (type IN ('comment', 'chat', 'team_invite'));

-- Add team_invitation_id column for team invite notifications
ALTER TABLE mention_notifications 
ADD COLUMN IF NOT EXISTS team_invitation_id BIGINT REFERENCES team_invitations(id) ON DELETE CASCADE;

-- Create index for team_invitation_id lookups
CREATE INDEX IF NOT EXISTS idx_mention_notifications_team_invitation_id 
ON mention_notifications(team_invitation_id) 
WHERE team_invitation_id IS NOT NULL;

-- 2. Trigger function to create notification when team invitation is created
-- Also sends push notification via pg_net HTTP call to edge function
CREATE OR REPLACE FUNCTION trigger_create_team_invite_notification()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_invited_user_id UUID;
    v_inviter_name TEXT;
    v_team_name TEXT;
    v_kicker_id BIGINT;
    v_content_preview TEXT;
    v_supabase_url TEXT;
    v_service_role_key TEXT;
    v_request_id BIGINT;
BEGIN
    -- Get invited player's user_id
    SELECT user_id INTO v_invited_user_id 
    FROM player 
    WHERE id = NEW.invited_player_id;
    
    -- Skip if player has no user_id (guest player)
    IF v_invited_user_id IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Get inviter's name
    SELECT name INTO v_inviter_name 
    FROM player 
    WHERE id = NEW.inviting_player_id;
    
    -- Get team name and kicker_id
    SELECT name, kicker_id INTO v_team_name, v_kicker_id 
    FROM teams 
    WHERE id = NEW.team_id;
    
    -- Build content preview message
    v_content_preview := v_inviter_name || ' invited you to join team "' || v_team_name || '"';
    
    -- Insert notification (for bell icon)
    INSERT INTO mention_notifications (
        user_id,
        type,
        source_id,
        match_id,
        kicker_id,
        sender_player_id,
        content_preview,
        team_invitation_id,
        is_read,
        created_at
    ) VALUES (
        v_invited_user_id,
        'team_invite',
        NEW.id,  -- source_id = invitation id
        NULL,    -- no match_id for team invites
        v_kicker_id,
        NEW.inviting_player_id,
        v_content_preview,
        NEW.id,
        FALSE,
        NOW()
    );
    
    -- Send push notification via pg_net HTTP call to edge function
    -- Get Supabase URL and service role key from vault (or use direct values)
    SELECT decrypted_secret INTO v_supabase_url 
    FROM vault.decrypted_secrets 
    WHERE name = 'supabase_url';
    
    SELECT decrypted_secret INTO v_service_role_key 
    FROM vault.decrypted_secrets 
    WHERE name = 'service_role_key';
    
    -- Only send push if we have the secrets configured
    IF v_supabase_url IS NOT NULL AND v_service_role_key IS NOT NULL THEN
        SELECT net.http_post(
            url := v_supabase_url || '/functions/v1/send-push-notification',
            headers := jsonb_build_object(
                'Content-Type', 'application/json',
                'Authorization', 'Bearer ' || v_service_role_key
            ),
            body := jsonb_build_object(
                'type', 'INSERT',
                'table', 'team_invitations',
                'schema', 'public',
                'record', jsonb_build_object(
                    'id', NEW.id,
                    'team_id', NEW.team_id,
                    'inviting_player_id', NEW.inviting_player_id,
                    'invited_player_id', NEW.invited_player_id,
                    'status', NEW.status
                )
            )
        ) INTO v_request_id;
    END IF;
    
    RETURN NEW;
END;
$$;

-- 3. Create trigger on team_invitations INSERT
DROP TRIGGER IF EXISTS trigger_team_invite_notification ON team_invitations;
CREATE TRIGGER trigger_team_invite_notification
    AFTER INSERT ON team_invitations
    FOR EACH ROW
    EXECUTE FUNCTION trigger_create_team_invite_notification();

-- 4. Trigger function to mark notification as read when invitation is responded to
CREATE OR REPLACE FUNCTION trigger_mark_team_invite_notification_read()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Only act when status changes from 'pending' to something else
    IF OLD.status = 'pending' AND NEW.status != 'pending' THEN
        UPDATE mention_notifications
        SET is_read = TRUE
        WHERE team_invitation_id = NEW.id AND is_read = FALSE;
    END IF;
    
    RETURN NEW;
END;
$$;

-- 5. Create trigger on team_invitations UPDATE
DROP TRIGGER IF EXISTS trigger_team_invite_response ON team_invitations;
CREATE TRIGGER trigger_team_invite_response
    AFTER UPDATE ON team_invitations
    FOR EACH ROW
    EXECUTE FUNCTION trigger_mark_team_invite_notification_read();

-- 6. Update get_mention_notifications to include team info for team_invite type
-- Must DROP first because return type is changing (adding team_invitation_id and team_info columns)
DROP FUNCTION IF EXISTS get_mention_notifications(INT, INT);

CREATE OR REPLACE FUNCTION get_mention_notifications(p_limit INT DEFAULT 50, p_offset INT DEFAULT 0)
RETURNS TABLE (
    id BIGINT,
    type VARCHAR(20),
    source_id BIGINT,
    match_id BIGINT,
    kicker_id BIGINT,
    kicker_name TEXT,
    sender_player_id BIGINT,
    sender_player_name TEXT,
    sender_avatar TEXT,
    content_preview TEXT,
    is_read BOOLEAN,
    created_at TIMESTAMPTZ,
    match_info JSONB,
    team_invitation_id BIGINT,
    team_info JSONB
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        mn.id,
        mn.type,
        mn.source_id,
        mn.match_id,
        mn.kicker_id,
        k.name AS kicker_name,
        mn.sender_player_id,
        p.name AS sender_player_name,
        p.avatar AS sender_avatar,
        mn.content_preview,
        mn.is_read,
        mn.created_at,
        CASE 
            WHEN mn.match_id IS NOT NULL THEN
                jsonb_build_object(
                    'id', m.id,
                    'player1_name', p1.name,
                    'player2_name', p2.name,
                    'player3_name', p3.name,
                    'player4_name', p4.name,
                    'scoreTeam1', m."scoreTeam1",
                    'scoreTeam2', m."scoreTeam2"
                )
            ELSE NULL
        END AS match_info,
        mn.team_invitation_id,
        CASE 
            WHEN mn.team_invitation_id IS NOT NULL THEN
                jsonb_build_object(
                    'invitation_id', ti.id,
                    'team_id', t.id,
                    'team_name', t.name,
                    'team_logo_url', t.logo_url,
                    'invitation_status', ti.status
                )
            ELSE NULL
        END AS team_info
    FROM mention_notifications mn
    JOIN kicker k ON k.id = mn.kicker_id
    JOIN player p ON p.id = mn.sender_player_id
    LEFT JOIN matches m ON m.id = mn.match_id
    LEFT JOIN player p1 ON p1.id = m.player1
    LEFT JOIN player p2 ON p2.id = m.player2
    LEFT JOIN player p3 ON p3.id = m.player3
    LEFT JOIN player p4 ON p4.id = m.player4
    LEFT JOIN team_invitations ti ON ti.id = mn.team_invitation_id
    LEFT JOIN teams t ON t.id = ti.team_id
    WHERE mn.user_id = auth.uid()
    ORDER BY mn.created_at DESC
    LIMIT p_limit
    OFFSET p_offset;
END;
$$;


-- Migration 049: Fix team bounty not being added to MMR (public schema)
-- The bounty_claimed was being stored but NOT added to the team's MMR
-- This fix adds p_bounty_claimed to the MMR calculation (same as player bounty logic)

SET search_path TO public;

DROP FUNCTION IF EXISTS update_team_season_ranking_with_bounty(BIGINT, BIGINT, INTEGER, BOOLEAN, INTEGER);

CREATE OR REPLACE FUNCTION update_team_season_ranking_with_bounty(
    p_team_id BIGINT,
    p_season_id BIGINT,
    p_mmr_change INTEGER,
    p_won BOOLEAN,
    p_bounty_claimed INTEGER DEFAULT 0
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Ensure ranking exists
    PERFORM get_or_create_team_season_ranking(p_team_id, p_season_id);
    
    -- Update the ranking
    -- Add bounty_claimed to MMR for winner (same as player bounty logic)
    UPDATE team_season_rankings
    SET 
        mmr = mmr + p_mmr_change + p_bounty_claimed,
        wins = CASE WHEN p_won THEN wins + 1 ELSE wins END,
        losses = CASE WHEN NOT p_won THEN losses + 1 ELSE losses END,
        bounty_claimed = bounty_claimed + p_bounty_claimed
    WHERE team_id = p_team_id AND season_id = p_season_id;
END;
$$;

GRANT EXECUTE ON FUNCTION update_team_season_ranking_with_bounty(BIGINT, BIGINT, INTEGER, BOOLEAN, INTEGER) TO authenticated;
